# 2. 파이썬스러운(pythonic) 코드

파이썬스러운 코드를 작성하는 데 여러가지 이유가 있다.

- 관용적 방식으로 코드를 작성했을 때 일반적으로 더 나은 성능을 낸다.
- 코드도 더 작고 이해하기 쉽다.
- 동일한 패턴과 구조에 익숙해지면 실수를 줄이고 문제의 본질에 보다 집중할 수 있게 된다.



## 인덱스와 슬라이싱



### 자체 시퀀스 생성

시퀀스는 `__getitem__`  과 `__len__` 을 모두 구현하는 객체이므로 반복이 가능하다. 리스트 튜플과 문자열은 표준 라이브러리에 있는 시퀀스 객체의 예이다.

사용자 정의 클래스에 `__getitem__`을 구현하려는 경우 파이썬스러운 접근방식을 위해 몇가지를 고려해야한다.

- 범위로 인덱싱하는 결과는 해당 클래스와 같은 타입의 인스턴스이여야 한다.
- slice에 의해 제공된 범위는 파이썬이 하는 것 처럼 마지막 요소는 제외해야 한다.



## 컨텍스트 관리자

주요 동작의 전후에 작업을 실행하려고할 때 유용하게 사용할 수 있는 파이썬의 기능이다.

`with`문 `PEP-343`은 컨텍스트 관리자로 진입하게 한다. 이는 `__enter__`, `__exit__` 두개의 매직 메서드로 구성된다.

`__enter__`는 컨텍스에 진입할 때 필요한 논리를 작성하고 리턴값을 작성한다. 이는 `as`로 받을 수 있지만 리턴하지 않아도 된다.

`__exit__`는 끝날 때 논리를 작성한다.



### 컨텍스트 관리자 구현

컨텍스트 관리자를 좀더 간결하게 구현할 수 있는 모듈을 파이썬에서 제공한다.

`contextlib.contextmanager` , `contextlib.ContextDecoratory` 등을 사용하여 다양하게 컨텍스트를 적용할 수 있는 방법을 제공해준다.



## 프로퍼티, 속서오가 객체 메서드의 다른 타입들

밑줄로 시작하는 속성은 해당 객체에 대해 private를 뜻하며, 외부에서 호출하지 않기를 기대하는 것이다. 하지만 이를 금하는 것은 아니다.

밑줄 두개를 사용하면 실제 파이썬은 다른 이름을 만든다. 이름 맹글링이라는 규칙을 통해 `_<class-name>__<attribute_name>`형태의 변수명으로 바꾸게된다.

파이썬에서 이중 밑줄은 여러번 확장되는 클래스에서 충돌을 없애기 위해 사용한다.



### 프로퍼티

프로퍼티는 객체의 어떤 속성에 대한 접근을 제어하려는 경우 사용한다.

프로퍼티는 명령-쿼리 분리의 원칙을 따르기 좋은 방법이다. 이 원칙은 객체의 메서드가 무언가의 상태를 변경하는 커맨드이거나 무언가의 값을 반환하는 쿼리이거나 둘중 하나만 수행해야한다.

즉, 한 메서드에서 한가지 이상의 일을 하지 말라는 것이다.



## 이터러블 객체

파이썬의 반복은 이터러블 프로토콜이라는 자체 프로토콜을 사용해 동작한다.

객체를 반복할 수 있는지 확인하기위해 파이썬은 고수준에서 다음 두가지를 차례로 검사한다.

- 객체가 `__next__`나 `__iter__` 이터레이터 메서드 중 하나를 포함하는지 여부
- 객체가 시퀀스이고 `__len__`과 `__getitem__`를 모두 가졌는지 여부



### 이터러블 객체 만들기

객체를 반복하려고 하면 파이썬은 해당 객체의 `iter()` 함수를 호출한다. 이 함수가 처음으로 하는 것은 해당 객체에 `__iter__` 메서드가 있는지 확인하고 있다면 실행한다.

for 루프의 작동 원리는 StopIteration 예외가 발생할 때까지 next()를 호출하는 것과 같다.

하지만 두개 이상의 for 루프에서 사용하게되면 두번째 루프에는 작동하지 않게 된다.

이 문제를 해결하는 방법은 매번 새로운 인스턴스를 만드는 것이다. 하지만 제너레이터를 사용하면 매번 인스턴스를 새로 만들지 않아도 된다. 이러한 객체를 이터러블 컨테이너라고 한다.



### 시퀀스 만들기

객체에 `__iter__`가 정의되어있지 않으면 `__getitem__`을 찾고 없으면 TypeError를 발생시킨다.

시퀀스는 `__len__`과 `__getitem__`을 구현하고 첫번째 인덱스 0부터 시작하여 포함된 요소를 한번에 하나씩 차례로 가져올 수 있어야한다.

이전 이터러블 객체는 메모리를 적게 사용한다는 장점이 있지만 n번째 요소를 얻기위해서는 O(n)의 시간이 걸리게된다. 이 방법은 모든 내용을 메모리에 사용하지만 O(1)로 가져올 수 있다. 

파이썬의 일관성과 호환성을 위해 음수 인덱싱도 적용된다.



## 컨테이너 객체

컨테이너는 `__contains__` 메서드를 구현한 객체로 `__contains__` 메서드는 일반적으로 Boolean 값을 반환한다.

`element in container`는 `container.__contains__(element)`로 해석된다.

구성이 간단하고 파이썬스럽게 문제를 해결한것처럼 보인다.



## 객체의 동적 속성

`__getattr__` 매직 메서드를 사용해 객체에서 속성을 얻는 방법을 제어할 수 있다. `<myobject>.<myattribute>`를 호출하면 파이썬은 객체의 사전에서 `<myattribute>`를 찾아서 `__getattribute__`를 호출한다. 객체에서 찾고있는 속성이 없는 경우 속성의 이름을 파라미터로 전달하여 `__getattr__`이라는 추가 메서드가 호출된다.



## 호출형 객체

매직메서드 `__call__`을 사용하면 객체를 일반 함수처럼 호출할 수 있다. 주된 이점은 객체에는 상태가 있기 때문에 함수 호출 사이 정보를 저장할 수 있다. 이 메서드는 객체를 파라미터가 있는 함수처럼 사용하거나 정보를 기억하는 함수의 경우 유용하다.



## 파이썬에서 유의할 점

방어코드를 작성하지않으면 발생할 수 있는 이슈가 많아진다. 



### 변경 가능한 파라미터의 기본 값

변경 가능한 객체를 함수의 기본 인자로 사용하면 안된다. 동적인 기본값을 가지려면 초기값을 None으로 사용하고 함수 본문에서 기본 값을 할당한다.



### 내장 타입 확장

리스트, 문자열, 사전과 같은 내장 타입을 확장하는 올바른 방법은 collections 모듈을 사용한다. 이렇게하면 보다 투명한 인터페이스를 제공하고 견고한 코드를 만들 수 있다.