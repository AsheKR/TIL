# 6. 디스크립터로 더 멋진 객체 만들기

디스크립터는 파이썬의 객체지향 수준을 한 단계 더 끌어올려주는 혁신적인 기능으로 이 기능을 잘 활용하면 보다 견고하고 재사용성이 높은 추상화를 할 수 있다. 디스크립터의 기능을 제대로 활용하는 예는 라이브러리나 프레임워크에서 많이 발견할 수 있다.



## 디스크립터의 개요



### 디스크립터 매커니즘

디스크립터는 단지 디스크립터 프로토콜을 구현한 클래스의 인스턴스이다. 이 클래스는 다음 매직 메서드 중에 최소 한 개 이상을 포함해야 한다.

- `__get__`
- `__set__`
- `__delete__`
- `__set_name__`

다음과 같은 네이밍 컨벤션을 사용한다.

| 이름            | 의미                                                         |
| --------------- | ------------------------------------------------------------ |
| ClientClass     | 디스크립터 구현체의 기능을 활용할 도메인 추상화 객체. 디스크립터의 클라이언트이다. 클래스 속성으로 디스크립터를 갖는다. |
| DescriptorClass | 디스크립터 클래스                                            |
| client          | client = ClientClass()                                       |
| decorator       | decorator = DecoratorClass<br />이 객체는 클래스 속성으로서 ClientClass에 위치한다. |

이 프로토콜이 동작하려면 디스크립터 객체가 클래스 속성으로 정의되어야 한다는 것이다. 이 객체를 인스턴스 속성으로 생성하면 동작하지 않으므로 init 메서드가 아니라 클래스 본문에 있어야 한다.

클래스 속성을 객체로 선언하면 디스크립터로 인식되고, 클라이언트에서 해당 속성을 호출하면 객체 자체를 반환하는 것이 아니라 `__get__`의 결과를 반환한다.

디스크립터를 이용해 `__get__` 메서드 안쪽으로 논리를 추상화 할 수 있으며 클라이언트에게 내용을 숨긴 채로 모든 유형의 변환을 분명하게 실행할 수 있다. 이는 새로운 레벨의 캡슐화이다.



### 디스크립터 프로토콜의 메서드

공통으로 self는 디스크립터 객체 자신을 의미한다.

#### - `__get__(self, instance, owner)`

**instance**는 디스크립터를 호출한 객체, client를 의미한다.

**owner**는 파라미터는 client 객체의 클래스를 의미한다.

**instance**를 통해 **owner**를 구할 수 있음에도 왜 시그니쳐에 정의되었을까.  이는 ClientClass에서 직접 호출하는 특별한 경우가 될 때 instance가 None을 가지게 되므로 Class를 알 수 없는 상황이 올 수 있다. 따라서 굳이 따로 파라미터를 준것이다.

```python
class DescriptorClass:
    def __get__(self, instance, owner):
        if instance is None:
            return f"{self.__class__.__name__}.{owner.__name__}"
        return f"value for {instance}"
    
class ClientClass:
    descriptor = DescriptorClass()
    
# 실제 사용
ClientClass.descriptor
'DescriptorClass.ClientClass'

ClientClass().descriptor
'value for <<module>.ClientClass object at 0x...>'
```



#### - `__set__(self, instance, value)`

디스크립터에 값을 할당하려고 할 때 호출된다. 



#### - `__delete__(self, instance)`

디스크립터에 값을 삭제할 때 호출된다.



#### - `__set_name__(self, owner, name)`

클래스에 디스크립터 객체를 만들 때는 디스크립터가 처리하려는 속성의 이름을 알아야 한다. 속성의 이름은 `__dict__`에서 `__get__`과 `__set__` 메서드로 읽고 쓸 때 사용된다.

파이썬 3.6 이전에는 디스크립터가 이 이름을 자동으로 설정하지 못했기 때문에 보통은 객체 초기화시 명시적으로 이름을 전달했다. 이렇게 해도 잘 동작하지만 이름을 중복해서 사용해야하는 불편함이 있었다. 

속성의 이름을 두번 쓰지 않으려면 데코레이터나 메타클래스를 사용하는 트릭을 사용해야했었지만 `__set_name__`을 함께 사용하여 이름을 바로 가져올 수 있다.



## 디스크립터의 유형

`__set__`이나 `__delete__` 메서드를 구현했다면 **데이터 디스크립터**

`__get__`만을 구현한다면 **비데이터 디스크립터**



### 비 데이터 디스크립터

비 데이터 디스크립터는 클라이언트 객체에 `__dict__`에 같은 이름의 속성이 존재하면 클라이언트 객체의 속성을 불러오게된다. 만약 클라이언트 객체에 속성이 존재하지 않으면 그제서야 디스크립터 클래스의 속성을 사용하게 된다.

`__get__`만 구현했기 때문에 디스크립터 속성에 값을 넣으려 시도하면 클라이언트 객체의 속성에 들어가게된다.



### 데이터 디스크립터

```python
class DataDescriptor:
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return 42
    
    def __set__(self, instance, value):
        logger.debug("%s.descriptor를 %s 값으로 설정", instance, value)
        instance.__dict__["descriptor"] = value
```

이번에는 `__set__`을 구현했기 때문에 디스크립터 속성에 값을 넣으려 시도할 때 디스크립터의 `__set__`이 실행되서 logger 문이 실행된다.

 ```python
instance.__dict__["descriptor"] = value
 ```

여기서 왜 다른 방법을 사용하지 않고 직접 `__dict__`에 접근했을까?

```python
setattr(instance, "descriptor", value)
```

디스크립터 속성에 무언가 할당하려고 하면 `__set__` 메서드가 호출된다. `__set__`은 `setattr`을 호출하고 다시 디스크립터의 `__set__`이 호출되고 `setattr`을 호출하고.. 이렇게 무한 루프가 발생한다.

다른 방법으로 디스크립터가 모든 인스턴스의 프로퍼티를 저장하려고 해보자.

클라이언트 클래스는 이미 디스크립터의 참조를 가지고 있고 디스크립터가 클라이언트 클래스의 참조를 가진다면 순환참조가 발생하여 가비지 컬렉션이 되지 않는 문제가 발생한다.

이는 `weakref`로 해결할 수 있다.



## 디스크립터 사용 예

만약 프로퍼티마다 중복되는 코드가 있다면 그것은 디스크립터로 중복을 없애는 것이 좋다.

디스크립터의 좋은 사용에는 어떤 비즈니스 로직도 포함되어 있으면 안된다. 따라서 완전히 다른 어떤 클래스에서 적용하여도 같은 효과를 본다.

디스크립터는 비즈니스 로직의 구현보다는 라이브러리, 프레임워크 또는 내부 API를 정의하는데 적합하다.



### 다른 형태의 디스크립터

#### - 전역 상태 공유 이슈

디스크립터는 클래스 속성으로 설정해야한다. 그러므로 디스크립터의 `__set__`에서 각 인스턴스에 속성을 할당한 것이 아니라면 클래스 전역에서 공유하게된다.

이를 해결하기 위해 디스크립터는 각 인스턴스의 값을 보관했다가 반환해야 한다. 이것이 각 인스턴스의 `__dict__` 사전에 값을 설정하고 검색하는 이유이다.

#### - 약한 참조 사용

`__dict__`를 사용하지 않으려는 경우 다른 대안은 디스크립터 객체가 직접 내부 매핑을 통해 각 인스턴스의 값을 보관하고 반환하는 것이다.

이렇게 하는 것에는 주의사항이 있다. 내부 매핑시 사전을 사용하면 안된다. 클라이언트 클래스는 디스크립터에 대한 참조를 가지고 디스크립터는 사용하는 객체에 대한 참조를 가지므로 순환 종속성이 생겨 결과적으로 결코 가비지 컬렉션이 되지 않는 문제가 있다.

이를 해결하기 위해 사전은 `weakref` 모듈에 정의된 것처럼 약한 키가 되어야 한다.

`wearkref`로 문제를 해결할 수 있지만 몇가지 고려사항이 있다.

- 인스턴스 객체는 더 이상 속성을 보유하지 않는다. 디스크립터가 속성을 보유한다. 이는 다소 논란의 여지가 있으며 개념적 관점에서 보면 완전히 정확하지 않을 수 있다.

- 객체는 `__hash__` 메서드를 구현하여 해시가 가능해야 한다. 가능하지 않다면 WeakKeyDictionary에 매핑할 수 없다.

이러한 이유로 각 인스턴스에 `__dict__` 사전을 사용하는 것을 권장한다.



### 디스크립터에 대한 추가 고려사항



#### - 코드 재사용

가장 좋은 방법은 프로퍼티가 필요한 구조가 반복되는 경우를 찾는 것이다.

디스크립터는 데코레이터가 클래스 메서드에도 동작할 수 있도록 도와 더 나은 데코레이터를 만들 수 있게 한다.

데코레이터는 항상 `__get__()`메서드를 구현하고 디스크립터를 사용하는 것이 안전하다고 할 수 있다.

클라이언트가 사용하게 되는 내부 API에 대해서는 디스크립터를 사용하는 것이 좋다는 것이다. 이는 일회성 솔루션이 아닌 라이브러리나 프레임워크의 디자인에 대해서는 기능을 확장하기가 좋기 때문이다.

일반적으로 디스크립터에 비즈니스 로직을 넣지 않아야하고 구현코드가 더 많이 포함되어 있어야한다.



#### - 클래스 데코레이터 피하기

클래스 데코레이터를 사용하여 인스턴스 속성에 다른 작업을 추가하는것보다 디스크립터를 사용하여 작성하는 것이 클래스가 훨씬 깔끔해보인다.



## 디스크립터 분석

디스크립터는 파이썬 내부 구현에도 사용되었다.



### 함수와 메서드

디스크립터 객체 중 가장 멋있는 예는 함수일 것이다. 함수는 `__get__` 메서드를 구현했기 때문에 클래스 안에서 메서드처럼 동작할 수 있다.

```python
instance = MyClass()
instance.some_method(...)

# 위의 코드는 디스크립터의 도움을 받아 내부적으로 아래처럼 처리된다.

instance = MyClass()
MyClass.some_method(instance, ...)
```

함수는 디스크립터 프로토콜을 구현했으므로 메서드를 호출하기 전에 `__get__()` 메서드가 먼저 호출되고 필요한 변환을 한다.

method는 클래스 속성으로 정의된 객체이고 `__get__` 메서드가 있기 때문에 `__get__` 메서드가 호출된다. 그리고 `__get__` 메서드가 하는 일은 함수를 메서드로 변환하는 것이다. 즉 함수를 작업하려는 객체의 인스턴스에 바인딩한다.

```python
class Method:
    def __init__(self, name):
        self.name = name
        
    def __call__(self, instance, arg1, arg2):
        print(f"{self.name}: [instsance] 호출됨, 인자는 {arg1}와 {arg2}입니다.")
        
class MyClass:
    method = Method("Internal call")
```

위 내용을 기반으로 객체를 만들었다면 다음과 두가지 호출은 동일한 역할을 해야한다.

```python
instance = MyClass()
Method("External call")(instance, "first", "second")
instance.method("first", "second")
```

두번째 호출에서 에러가 발생한다.

`Method.__call__`기준으로  self 자리에 instace가 전달되고, instance 자리에 first가 전달되고,arg1 자리에 second가 전달되고 arg2에 아무값도 전달되지 않으므로 에러가 발생한다.

이 문제를 해결하려면 메서드를 디스크립터로 변경하면 된다.

그렇게 하면 instance.method 호출 시 `Method.__get__` 메서드를 먼저 호출할 것이다. 여기에서 첫 번째 파라미터로 Method의 인스턴스를 전달함으로서 객체에 바인딩 하면 된다.

```python
from types import MethodType

class Method:
    def __init__(self, name):
        self.name = name
        
    def __call__(self, instance, arg1, arg2):
        print(f"{self.name}: [instsance] 호출됨, 인자는 {arg1}와 {arg2}입니다.")
        
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return MethodType(self, instance)
    
class MyClass:
    method = Method("Internal call")
```

이렇게 만들면 위의 코드는 정상적으로 동작하게 된다.

types 모듈의 MethodType을 사용하여 함수를 메서드로 변환한다. MethodType의 첫번째 파라미터는 호출 가능한것이여야하고 (Method는 `__call__`을 구현하여 호출 가능한 형태이다.) 두번째 파라미터는 이 함수에 바인딩할 객체이다.

이는 매우 우아한 처리 방법으로 사용자 정의 객체를 만들 때도 이러한 파이썬스러운 접근 방식을 염두에 두는 것이 좋다. 예를 들어 사용자 정의 호출 가능 객체를 정의할 때는 지금처럼 디스크립터로 만들어 클래스 속성으로도 사용할 수 있도록 하는 것이 좋다.



### 메서드를 위한 빌트인 데코레이터

@property, @classmethod와 @staticmethod 데코레이터는 디스크립터이다.

@classmethod를 사용하면 디스크립터의  `__get__` 함수가 메서드를 인스턴스에서 호출하든 클래스에서 직접 호출하든 상관없이 데코레이팅 함수에 처섭ㄴ재 파라미터로 메서드를 소유한 클래스를 넘겨준다.

@staticmethod를 사용하면 정의한 파라미터 이외의 파라미터를 넘기지 않도록 한다. 즉, `__get__` 메서드에서 함수의 첫 번째 파라미터에 self를 바인딩하는 작업을 취소한다.



### 데코레이터를 디스크립터로 구현하기

클래스 메서드에도 적용 가능한 데코레이터를 만들려면 데코레이터 클래스에 `__get__()` 메서드를 구현한다.



## 요약

디스크립터는 파이썬의 경계를 보다 메타프로그래밍에 가깝게 해주는 고급 기능이다.

디스크립터는 강력한 장점을 많이 가지고 있지만 불필요한 오버 엔지니어링에 사용되지 않도록 주의해야 한다. 이러한 측면에서 디스크립터는 내부 API 개발이나 라이브러리 또는 프레임워크 디자인과 같은 일반적인 경우에 대해서만 사용해야한다. 