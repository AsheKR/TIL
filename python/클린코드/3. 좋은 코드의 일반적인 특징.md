# 3. 좋은 코드의 일반적인 특징

궁극적인 목표는 코드를 가능한 견고하고 결함을 최소화하고 완전히 자명하도록 하는 것이다. 



## 계약에 의한 디자인

코드가 정상적으로 동작하기 위해 기대하는 것과 호출자가 반환 받기를 기대하는 것은 디자인의 하나가 되어야 한다. 

컴포넌트 간의 통신 중 반드시 지켜야 할 몇가지 규칙을 강제하는 것이다.

- 사전 조건: 코드가 실행되기 전 체크해야하는 것들이다. 함수가 진행되기 전 처리되어야 하는 모든 조건을 체크한다. 
- 사후 조건: 반환값의 유효성 검사가 수행된다.



계약에 의해 디자인을 하는 이유는 오류가 발생할 때 쉽게 찾아낼 수 있기 때문이다. 어떤 부분에서 실패했다는 에러를 발생시키는데 그치는것이 아니라 책임의 한계를 명확히하는데 도움이 된다.

사전 조건은 클라이언트와 연관이 있고, 사후 조건은 컴포넌트와 연관이 있다. 이렇게 하면 책임소재를 신속히 파악할 수 있다.



### 사전 조건

함수나 메서드가 제대로 동작하기 위해 보장해야하는 모든 것, 적절한 데이터를 전달해야함을 뜻한다.

함수는 처리할 정보에 대한 적절한 유효성을 검사한다. 클라이언트에서 검사하는 것을 **관용적 접근법**이라 하고 함수 자체에서 유효성을 검사하는 것을 **까다로운 접근 방법**이라고 한다.

까다로운 접근방법이 일반적으로 사용되고 안전하고 견고한 방법이다.

중복 제거의 원칙에 의해 검증을 양쪽에서 하지 않아야되는것도 중요하다.



### 사후 조건

메서드 또는 함수가 반환된 후의 상태를 강제하는 계약의 일부이다.

메서드가 적절히 실행된다면 클라이언트는 반환 객체를 아무 문제없이 사용할 수 있어야 한다.



### 결론

디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별하는데 있다.

또한 프로그램의 구조를 명확히 하는 목적으로도 사용된다. 가능한 모든 실패 시나리오를 검증하려고 하는 대신 계약은 명시적으로 함수나 메서드가 정상 동작하기 위해 기대하는 것이 무엇인지, 무엇을 기대할 수 있는지 정의한다.

이러한 원칙은 추가 작업이 발생한다. 핵심 논리뿐만 아니라 계약을 작성해야 하기 때문이다. 이러한 계약에 대한 단위 테스트를 추가해야 할 수도 있다. 이 방법을 통해 품질은 장기적으로 보상된다.

이 방법이 효과적이기 위해서는 무엇을 검증할 것인지 신중히 검토해봐야 하며 이는 굉장히 중요한 부분이다.



요즘에는 주석으로 남기지 않고 실행가능한 명세(테스트코드)로 남기는 것 같다.

주석은 코드와의 싱크가 불일치할 수 있기 때문이다.



## 방어적 프로그래밍

주요 주제는 시나리오의 오류를 처리하는 방법과 발생하지 않아야 하는 오류를 처리하는 방법에 대한 것이다. 전자는 **에러 핸들링 프로시저**에 관한 것이며, 후자는 **어썰션**에 관한 것이다.



### 에러 핸들링

오류가 발생하기 쉬운 상황에서 에러 핸들링 프로시저를 사용하는데 일반저그올 데이터 입력 확인 시 자주 사용된다. 주요 목적은 예상되는 에러에 대해 실행을 계속할 수 있을지 아니면 극복할 수 없는오류여서 프로그램을 중단할지를 결정하는 것이다.



#### - 값 대체

일부 시나리오에서는 오류가 있어 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험에 있을 경우 결과 값을 안전한 다른 값으로 대체할 수 있다.

일반적으로 누락된 파라미터를 기본 값으로 바꾸어도 큰 문제가 없지만 오류가 있는 데이터를 유사한 값으로 대체하는 것은 더 위험하며 일부 오류를 숨겨버릴 수도 있다.



#### - 예외처리

에러가 발생하기 쉽다는 가정으로 계속 실행하는 것보다 차라리 실행을 멈추는 것이 더 좋다. 이런 경우 호출자에게 실패했음을 알리는 것이 좋은 선택이다. Dbc에서 보았듯이 사전 조건 검증이 실패한 경우이다.

함수는 심각한 오류에 대해 명확하고 분명하게 알려줘서 적절하게 해결할 수 있도록 해야 한다. 

예외를 사용하여 시나리오나 비즈니스 로직을 처리하려고 하면 프로그램의 흐름을 읽기 어려워진다. 예외는 캡슐화를 약화시키기 때문에 신중하게 사용해야 한다. 함수에 예외가 많을수록 호출자가 호출하는 함수에 대해 더 많은 것을 알아야만 한다.

예외가 많이 발생하면 여러 개의 작은 것으로 나눠야한다는 신호일 수 있다.

예외는 오직 한 가지 일을 하는 함수의 한 부분이여야하고 함수가 처리하는 캡슐화된 로직과 일치하여야한다.



#### - Traceback 노출 금지

이 정보는 매우 유용한 정보여서 중요 정보나 지적 재산의 유출이 발생할 위험이 있다.



#### - 비어있는 except 블록 지양

아무것도 하지 않은 채 조용히 지나쳐버리는 비어있는 except는 가장 안좋은 예이다.

보다 구체적인 예외를 사용하고 실제 오류 처리를 except에서 처리하도록 하자.



#### - 원본 예외 포함

오류 처리 과정에서 다른 오류를 발생시키고 메세지를 변경할 수 있다.

파이썬은 `raise <e> from <original_exception>` 구문을 사용하여 원본 예외를 포함한 새 exception에 포함할 수 있다.



### 파이썬에서 어썰션 사용하기

어설션은 절대로 일어나지 않아야 하는 상황에 사용되므로 assert문에 사용된 표현식은 불가능한 조건을 의미한다. 이 상태가 된다는 건 소프트웨어에 결함이 있음을 의미한다.

에러 핸들링과 다르게 프로그램을 중단해야한다. 이러한 이유로 어설션은 비즈니스 로직과 섞거나 소프트웨어의 제어 흐름 매커니즘으로 사용해서는 안된다.



## 관심사의 분리

책임이 다르면 컴포넌트, 계층 또는 모듈로 분리되어야 한다. 프로그램의 각 부분은 기능의 일부분에 대해서만 책임을 지며 나머지 부분에 대해서는 알 필요가 없다.

관심사를 분리하는 목표는 파급 효과를 최소화하여 유지보수성을 향상시키는 것이다. 파급 효과는 어느 지점에서의 변화가 전체로 전파되는 것을 의미한다. 이러한 오류나 예외는 다른 예외를 유발하거나 혹은 먼 지점의 결함을 초래한다. 함수 정의를 약간만 변경해도 코드의 여러 부분에 영향을 미쳐 많은 코드를 변경해야 할 수도 있다.



### 응집력과 결합력

**응집력**이란 객체가 작고 잘 정의된 목적을 가져야 하며 가능하면 작아야 한다는 것을 의미한다.

**결합력**이란 두개 이상의 객체가 서로 어떻게 의존하는지 나타낸다.

**잘 정의된 소프트웨어는 높은 응집력과 낮은 결합력을 가진다**



## 개발 지침 약어

### DRY/OAOO

코드에 있는 지식은 단 하번, 단 한 곳에 정의되어 있어야 한다. 코드를 변경하려고 할 때 수정이 피룡한 곳은 단 한군데만 있어야 한다.

중복을 제거하는 가장 간단한 방법으로 함수를 생성할 수 있으며 전체적으로 추상화하지 않은 경우 완전히 새로운 객체를 만드는 것이 좋다.



### YAGNI / KIS

스프트웨어 컴포넌트를 설계할 때 과잉 엔지니어링을 피하자. 디자인이 단순할수록 유지보수가 쉽기 때문이다.



### EAFP

일단 코드를 실행하고 동작하지 않을 경우 대응하는 것이다.

파이썬은 이 방식으로 만들어졌으며, 이 방식을 권한다.



## 컴포지션과 상속



### 상속이 좋은 선택인 경우

- 클래스의 기능을 그대로 물려받으면서 추가 기능을 더하려는 경우 또는 특정 기능을 수정하려는 경우
- 인터페이스를 정의하려는 경우. 구현하지 않는 추상 기본 클래스를 만들고 실제 이 클래스를 상속하는 하위 클래스에서 적절한 구현을 하도록 할 수 있다.

- 예외



### 상속 안티 패턴

클래스의 기능의 기능 중 모든 기능을 사용하지 않을 경우 문제가 발생한다. 내장 객체를 상속하는 경우 모든 기능을 사용하지 않을 때도 있다.

올바른 해결책은 컴포지션을 사용하는 것이다. 전체를 상속받는것이 아니라 내장 객체에서 활용할 수 있도록  특정 매직메서드를 구현하는 것이다.

이 방법은 개념적으로 정확할 뿐만 아니라 확정성도 뛰어나다.  이는 결합력을 줄이고 파급 효과를 최소화하며 보다 나은 리팩토링을 허용하고 코드를 유지 관리하기 쉽게 만든다.



### 파이썬의 다중 상속

#### - 메서드 결정 순서(MRO)

C3 알고리즘에 의해 상속받는 왼쪽에서 오른쪽순으로, 그리고 부모순으로 찾게된다.

#### - 믹스인(mixin)

코드를 재사용하기 위해 일반적인 행동을 캡슐화해놓은 기본 클래스





## 함수와 메서드의 인자



### 함수 인자의 개수

너무 많은 인자를 사용하는 함수나 메서드는 나쁜 디자인이다.

이를 해결하기 위해서는 다음 대안이 있다.

- 일반적 소프트웨어 디자인의 원칙을 사용하여 모든 인자를 포함하는 새로운 객체를 만든다.
- 가변인자나 키워드 인자를 사용하여 동적 서명을 가진 함수를 만든다.
  - 이는 매우 동적이여서 유지보수가 어렵다.
- 많은 값에 대응하여 너무 많은 것들을 함수에서 처리하고 있다면 여러 작음 함수로 분리하자.



## 소프트웨어 디자인 우수 사례 결론

좋은 소프트웨어 디자인이란 소프트웨어 엔지니어링의 우수 사례를 따르고 언어의 기능ㅇ이 제공하는 대부분의 장점을 활용하는 디자인이다.



### 소프트웨어의 독립성

외부 세계에 영향을 미치지 않아야한다는 것이다. 실제로는 완전히는 불가능하겠지만 가능한  영향을 최소화하려고 시도해야한다. 이러한 디자인 원칙으로 관심사의 분리, 응집력, 컴포넌트의 격리를 살펴보았다.



코드의 부분이 독립적이라는 것은 다른 부분에 영향을 주지 않고 변경할 수 있다는 것을 뜻한다. 애플리케이션의 두가지 기능이 완전히 독립적이라는 것은 다른 코드를 손상시킬 것에 대한 염려가 없으므로 간단한 테스트 후 배포할 수 있다.



### 코드 구조

여러 정의가 들어있는 큰 파일을 만드는 것은 좋지 않다. 좋은 코드라면 유사한 컴포넌트끼리 정리하여 구조화하여야 한다.

이로써 얻는 장점은 다음과 같다.

- 모듈 임포트시 구문을 분석하고 메모리에 로드할 객체가 줄어든다.
- 의존성이 줄었기 때문에 더 적은 모듈만 가져오면 된다.

또한 프로젝트를 위한 컨벤션을 갖는데에도 도움이 된다. 모든 파일에서  상수를 정의하는 대신, 프로젝트에서 사용할 상수 값을 저장할 특정 파일을 만들고 다음과 같이 임포트 하면 된다.

```python
from myporject.constatns import CONNECTION_TIMEOUT
```

이와 같이 정보를 중앙화하면 코드 재사용이 쉬워지고 실수로 인한 중복을 피할 수 있다.