# 파이썬 코딩의 기술



**기본 상식**

매개변수(Parameter)

전달인자(Argument)





## 파이썬 다운 생각



### bytes, str, unicode의 차이

**Python3** 에서는 **bytes**와 **str** 두가지 타입으로 문자 시퀀스를 나타낸다.

**bytes**는 8비트의 값을 저장하며 **str**은 유니코드 문자를 저장한다.



### 복잡한 표현식 대신 헬퍼 함수를 작성하자



### 시퀀스 슬라이스

최소한의 노력으로 아이템의 부분집합에 접근할 수 있는 방법을 파이썬에서 제공해준다.

`__getitem__`과 `__setitem__`으로 클래스에도 슬라이싱을 적용할 수 있다.



### 한 슬라이스에 start, end, stride를 함께 쓰지 말자

시퀀스 문법은 `somelist[start:end:stride]` 세가지를 사용할 수 잇다.

**stride**는 양수를 사용하는게 좋고 만약 세개를 같이 써야하는 경우 **stride**를 적용한 결과를 다른 변수에 할당하여 사용하는 것을 권장한다. 시간과 메모리가 충분치 않은 경우  **itertools**의 **islice** 메서드의 사용을 권장한다.



### map, filter 대신 리스트 컴프리헨션을 사용하자

추가적인 **lambda** 표현식이 없으므로 리스트 컴프리헨션이 가독성이 좋다.



### 리스트 컴프리헨션에서 표현식을 두개 넘게 사용하지 말자

가독성이 좋지 않으므로 피하도록 하자.



### 컴프리헨션이 클 때는 제너레이터 표현식을 고려하자

입력이 적을 때는 컴프리헨션도 괜찮지만 클 때는 메모리 소비가 크다.

리스트 컴프리헨션과 제너레이터를 일반화한 제너레이터 표현식을 제공한다.

제너레이터 표현식은 실행될 때 출력 시퀀스를 모두 계산하여 가지지 않는다. 표현식에서 한번에 한 아이템을 내주는 이터레이터로 평가된다.

제너레이터 표현식은 `()` 문자 사이에 리스트 컴프리헨션과 비슷한 문법을 사용하여 생성한다.

```python
it = (len(x) for x in open('tmp/my_file.txt'))
print(it)
# <generator object ...>
```

다음 출력을 생성하기 위해 `next()` 메서드를 사용한다.

```python
print(next(it))
# 100
print(next(it))
# 57
```

또 다른 장점은 다른 제너레이터 표현식과 함께 사용되어 빠르게 실행되는 점이다.

```python
roots = ((x, x ** 0.5) for x in it)
print(next(roots))

(15, 3.87298)
```

제너레이터가 반환된 이터레이터에는 상태가 있으므로 이터레이터를 한번 넘게 사용ㅎ지 않도록 하자.



### 시퀀스 접근은 range 보다는 enumerate를 사용하자



### 이터레이터 병렬 처리는 zip을 사용하자

인덱스를 사용하여 두개 이상의 이터레이터를 처리할수 있지만 그보다 더 유용한 **zip** 내장 함수를 지원한다.

```python
# enum
for i, name in enumerate(names):
    count = letters[i]
    if count > max_letters:
        longest_name = name
        max_letters = count
        
# zip
for name, count in zip(names, letters):
    if count > max_letters:
        longest_name = name
        max_letters = count
```

파이썬 2에서는 zip이 제너레이터가 아니기때문에 성능 문제가 발생할 수 있다.

반드시 **itertools**의 **izip**을 사용해야한다.

zip의 문제점은 입력 이터레이터의 길이가 다르면 한쪽이 끝나면 끝나게된다.

길이가 같다고 확신하지 못하면 **itertools**의 **zip_longest**를 사용하는 방안을 고려하자.



### for whie 루프 뒤에는 else 블록을 사용하지 말자

루프 본문에서 break를 만나야만 else 블록을 실행한다.

이는 직관적이지 않고 혼동하기 쉬우므로 사용하지말고 헬퍼 함수를 작성하는것을 권장한다.



### try/except/else/finally에서 각 블록의 장점을 이용하자

- **finally**: 예외 여부와 상관없이 실행
- **else**: try 블록의 양을 최소화하는데 도움을 주며, 예외를 일으키지 않으면 실행된다. finally 전에 실행되므로 추가 작업에 사용하는데 도움이 된다.



## 함수



### None을 반환하기보다는 예외를 일으키자

특별한 의미를 나타내려고 None을 반환하는 함수가 오류를 일으키기 쉬운 이유는 None은 다른 값이 조건식에서 False로 평가되기 때문이다.

특별한 상황을 알릴 때 None을 반환하는 대신 예외를 일으키자. 문서화가 되어 있다면 호출하는 코드에서 예외를 적절하게 처리할것이라고 기대할 수 있다.



### 클로저가 변수 스코프와 상호작용하는 방법을 알자

클로저 함수는 자신이 정의된 스코프 중 어디에 있는 변수도 참조할 수 있다.

기본적으로 클로저에서 변수를 할당하면 바깥 스코프에는 영향을 미치지 않는다.

파이썬3에서는 nonlocal문을 사용하여 클로저를 감싸고 있는 스코프의 변수를 찾아 수정할 수 있음을 알린다.

파이썬 2에서는 nonlocal을 지원하지 않는다. 리스트로 참조값을 변경하여 스코프 외부 변수를 수정할 수 있도록 우회한다.

간단한 함수 외에는 nonlocal을 사용하지 말자.



### 리스트를 반환하는 대신 제너레이터를 고려하자

제너레이터를 사용하는 방법이 누적된 결과의 리스트를 반환하는 방법보다 이해하기에 명확하다.

제너레이터에서 반환한 이터레이터는 제너레이터 함수의 본문에 있는 yield 표현식에 전달된 집합이다.

제너레이터는 모든 입력과 출력을 메모리에 저장하지 않으므로 입력값의 양을 알기 어려울 때도 연속된 출력을 만들 수 있다.



### 인수 순회할 때는 방어적으로 하자

입력 인수를 여러번 순회하는 함수 작성시에는 이터레이터의 동작에 유의하며 작성한다. 즉, **StopIteration**이 일어난 후 다시 해당 이터레이터를 사용할 수 없다.

이터레이터를 호출하기보다는 **이터레이터 프로토콜**을 사용하여 컨테이너가 이터레이터로 작동하는 방식을 사용하자.

```python
# 이터레이터
def normalize_func(get_iter):
    total = sum(get_iter())
    result = []
    for value in get_iter():
        percent = 100 * value / total
        result.append(percent)
    return result

# 이터러블 컨테이너 클래스를 사용
class ReadVisit(object):
    ...
    
    def __iter__(self):
        with open(self.data_path) as f:
            for line in f:
                yield int(line)
                
def normalize_defensive(numbers):
    # 컨테이너의 경우에는 내장함수 iter를 호출할때마다 새 이터레이터 객체가 발생한다.
    # 즉, 컨테이너가 아닌 경우 raise문이 발생한다. (단순 이터러블 "iter([1,2,3])"의 경우)
    if iter(numbers) is iter(numbers):
        raise TypeError("컨테이너여야만 한다.")
	...
```

`__iter__` 메서드를 사용하여 제너레이터로 구현하여 사용자정의 이터러블 컨테이너를 생성할 수 있다.



### 가변 위치 인수로 깔끔하게 보이게 하자

`*`연산자를 사용하여 가변 개수 위치 인수를 받을 수 있다.

제너레이터와 함께 가변 위치 인수가 사용될 경우 가변 위치 인수에 들어올것이 튜플로 변환되기 때문에 (메모리에 제너레이터로 생성된 모든 값이 메모리에 올라감) 주의한다.

가변 위치 인수는 새 위치 파라미터를 추가하기 어렵다.



### 키워드 선택 인수로 선택적 동작을 제공하자

키워드 인수는 함수 파라미터 제공에 명확한 이해를 돕는다.

키워드 인수는 기본값을 설정할 수 있다.

기본값을 사용하여 기존 코드 호출코드와 호환성을 유지하면서 파라미터를 확장할 수 있다. 이 때 기본값이 있는 파라미터는 키워드 인수로 호출해야한다.



### 동적 기본 인수를 지정하려면 None과 Docstring을 사용하자

키워드 인수의 기본 값은 모듈 로드 시점의 함수 정의 과정에서 딱 한번 평가되고 공유된다.

동적 키워드 인수를 사용하기 위해서는 기본값을 None으로 설정한다. 그리고 나서 함수의 docstring에 실제 기본 동작을 작성한다.



### 키워드 전용 인수로 명료성을 강조하자

함수 호출 의도를 더 명확히 해준다.

불 플래그를 여러개 받는 함수는 위치인수는 헷갈리기 쉬워 키워드 인수를 사용하여야 하고, 기본값을 설정하여 필요한 옵션만 인자로 작성하게 할 수 있다.

파이썬 3에서는 `*` 기호를 사용하여 위치 인자의 끝을 나타내어 뒤의 것들은 모두 강제적으로 키워드 인자로 받아야함을 나타낸다.

```python
def safe_division_c(number, divisor, *,
                   ignore_overflow=False,
                   ignore_zero_division=False):
    ...
    
# 모두 위치 인수를 사용하면 에러가 발생한다.
safe_division_c(1, 10*500, True, False)
# TypeError: safe_division_c() takes 2 positional arguments but 4 were given
# 함수에서 위치인자가 2개 받는걸 예상했는데 4개가 받아졌다는 에러

# 아예 제공하지 않거나, 키워드 인수로 제공하면 정상적으로 작동한다.
```

파이썬 2에서는 `**kwargs`를 사용하고 TypeError를 명시적으로 발생하여 위의 동작을 흉내낼 수 있다.

```python
# 위치인자는 2개만을 허용한다.
def safe_division_d(number, divisor, **kwargs):
    ignore_overflow = kwargs.pop('ignore_overflow', False)
    ignore_zero_division = kwargs.pop('ignore_zero_division', False)
    # kwargs 안에 위 두개 키워드 인수 이외의 것을 허용하지 않는다.
    if kwargs:
        raise TypeError('Unexpected **kwargs: %r' % kwargs)
```





