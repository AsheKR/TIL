# 네트워크



## HTTP / HTTPS

1. [HTTP/1.1](#HTTP/1.1)
2. [HTTP/2](#HTTP/2)
3. [HTTPS](#HTTPS)
4. [SSL](#SSL)



### HTTP/1.1

Client(Chrome, Firefox)와 Server(nginx, httpd)간 통신을 위한 Protocol

C/S간 통신을 위해 단순히 Request/Response 과정을 거치게된다.

**HTTP/1.1은 기본적으로 Connection당 하나의 요청을 처리하도록 설계**되었다. 그렇기때문에 **동시전송이 불가능**하고 **요청과 응답이 순차적**으로 이루어지게된다.

#### HTTP/1.1 단점

순차적 요청/응답으로 다수의 리소스를 처리하려면 리소스의 개수에 비해 **Latency(대기 시간)**은 길어지게 된다.

#### 1. HOL (Head Of Line) Blocking - 특정 응답의 지연

Web 환경에서 HOLB는 두가지 존재한다.

- HTTP의 HOL Blocking
- TCP의 HOL Blocking

HTTP/1.1 connection당 하나의 요청처리를 개선할 수 있는 기법중 **pipelining**이 존재하는데 이는 하나의 Connection을 통해 다수의 파일을 요청/응답 받을 수 있게 하는 기법이다.

하지만 첫번째 파일을 요청할 때 첫 파일이 응답이 지연되면 응답처리가 완료되기전까지 다른 파일은 대기한다. 이를 **HTTP HOLB**라고 한다.

#### 2. RTT(Round Trip Time) 증가

매 요청별로 connection을 만들게되고 TCP상 동작하는 HTTP의 특성상 **3-way-handshake**가 반복적으로 일어나고 불필요한 RTT증가와 네트워크 지연을 초래하여 성능을 저하시킨다.

#### 3. 무거운 Header 구조 (특히 Cookie)

**HTTP/1.1**의 헤더에는 많은 메타 정보가 포함되어있다. 다수의 http요청시에는 매 요청시마다 중복된 헤더값을 전송하게되며 또한 도메인에 설정된 Cookie 정보도 매 요청시 헤더에 포함되며 전송하려는 값보다 헤더가 클 수도 있다.



### HTTP/2

HTTP/1.1의 **Latency**를 극복하기위해 HTTP를 고속화한 **SPDY**라는 새로운 프로토콜을 구현하여 사용하였었다. 이는 HTTP/2의 기반이되었다.

HTTP/2의 목적은 다음과 같다.

> HTTP 프로토콜을 완전히 다시작성하는 것이 아니라, HTTP 메서드, 상태 코드 및 의미는 동일하며 프로토콜을 나타내기위해 HTTP/1.x와 동일한 API를 사용할 수 있어아야한다. **HTTP/2의 초점은 성능에 있다.** 특히 최종 사용자가 대기 시간, 네트워크 및 서버 리소스 사용을 인식한다.

HTTP/2가 어떤 방식으로 성능향상을하는지 주요 요소에 대해 알아보자.



#### Multiplexed Streams

한 커넥션으로 동시에 여러 메세지를 주고받을 수 있으며, 응답은 순서에 상관없이 Stream으로 주고 받는다. Connection Keep-Alive, Pipelining의 개선형이라고 보면 된다.



#### Stream Prioritization

HTML 안에 CSS, Image가 존재하고 이를 클라이언트가 각각 요청하고 난 후 Image 파일보다 CSS 파일의 수신이 늦어지는 경우 브라우저의 렌더링이 늦어지는 문제가 발생하는데 **HTTP/2**의 경우 리소스간 우선순위를 설정하여 이런 문제를 해결하고 있다.



#### Server Push

클라이언트의 요청에 대해 요청하지도 않은 리소스를 마음대로 보내줄 수 있다.

클라이언트가 HTML 문서를 요청했고 리소스가 포함되어있는경우 HTTP/1.1의 경우 클라이언트가 필요한 리소스를 요청하는 반면 HTTP/2에선 Server Push기법을 통해서 클라이언트가 요청하지도 않은 리소스를 Push 해주는 방법으로 클라이언트의 요청을 최소화 해서 성능 향상을 이끌어낸다. 이를 PUSH_PROMISE라고 부르며 서버가 전송한 리소스에 대해선 클라이언트는 요청하지 않는다.



#### Header Compression

HTTP/2는 Header 정보를 압축하기 위해 **Header Table**과 **Huffman Encoding** 기법을 사용하여 처리하는데 이를 HPACK 압축방식이라 부르며 별도의 명세서로 관리하고 있다.

HTTP/1.x의 경우 두개의 요청 Header에 중복값이 존재해도 그냥 중복 전송한다. 하지만 HTTP/2에선 Header에 중복값이 존재하는 경우 **Static/Dynamic Header Table**개념을 사용하여 중복 Header를 검출하고 중복된 Header는 index값만 전송하고 중복되지 않은 Header의 정보값은 **Huffman Encoding**기법으로 인코딩 처리하여 전송한다.



### HTTPS



#### HTTP의 약점

- 평문이기때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능



##### HTTPS는 SSL의 껍질을 덮어쓴 HTTP

HTTP 통신을 하는 소켓 부분을 SSL이나 TSL이라는 프로토콜로 대체하고 있을 뿐이다.

HTTP는 직접 TCP와 통신하지만 SSL을 사용하는 경우 HTTP는 SSL와 통신하고 SSL이 TCP와 통신한다.



##### 용어 정리

- 디지털 인증서: SSL 인증서는 클라이언트와 서버간 통신을 제 3자가 보증해주는 전자화된 문서이다. 클라이언트가 서버에 접속한 직후 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지 검증한 후 다음 절차를 수행하게된다.
  - 통신 내용이 공격자에게 노출(암호화하여)되는 것을 막을 수 있다.
  - 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.
  - 통신 내용의 악의적인 변경을 방지할 수 있다.
- 대칭키: 대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 암호화 기법
- 공개키: 공개키 방식은 두개의 키를 갖는다. 개인키, 공개키로 나누어져있으며 공개키를 제공받은 타인은 공개키를 이용해 정보를 암호화한다. 암호화한 정보를 개인키를 가지고있는 자신이 복호화할 수 있다.

- CA: 인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들은 CA 혹은 Root Certificate라고 부른다.
  - CA를 브라우저는 알고 있다. 인증서를 이해하는데 꼭 알고 있어야하는 것이 CA 리스트이다. 이 리스트는 부라우저에서 자체적으로 가지고 있다.

### SSL 인증서

1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.
2. SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.



#### SSL 인증서의 내용

- 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)
- 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)



#### SSL 인증서가 서비스를 보증하는 방법

- 웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다.
- 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지 확인한다.
- 확인 결과 서버를 통해 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해 인증서를 복호화한다.
  - 비밀키로 암호화한 정보를 공개키로 복호화할 수 있다는 것은 그 정보가 틀림없이 쌍으로 존재하는 것이다. 즉 정보의 출처를 신뢰할 수 있다.



#### SSL의 동작방법

SSL은 암호화된 데이터를 전송하기 위해 공개키와 대칭키를 혼합하여 사용한다. **클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화하고, 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트 서버와 주고 받는다.**  (데이터는 대칭키로 암호화, 대칭키는 공개키로 암호화)

![HTTPS](https://github.com/cheese10yun/TIL/raw/master/assets/https-flow.png)

1. 클라이언트가 Client Hello 메세지를 송신하면서 SSL 통신을 시작한다. 메세지는 클라이언트가 제공하는 SSL 버전을 지정하고, **Cipher Suite**라고 불리는 리스트(사용하는 암호화알고리즘, 키 사이즈)가 포함된다.
2. 서버가 SSL 통신이 가능한 경우 Server Hello 메세지로 응답한다. 클라이언트와 같이 SSL 버전과 Cipher Suite를 포함한다. 서버의 Cipher Suite 내용은 클라이언트에서 받은 Cipher Suite의 내용에서 선택된 것이다.
3. 서버가 Certicate 메세지를 송신한다. 메세지에는 공개키 증명서가 포함되어있다.
4. 서버가 Server Hello Done 메세지를 송신하여 최초의 SSL Negotiation이 끝났음을 통지한다.
5. SSL의 최초 Negotiation이 종료되면 클라이언트가 Client Exchange 메세지로 응답한다. 메세지에는 통신을 암호화하는데 사용하는 **Pre-Master Secret**이 포함되어있다. 이 메세지는 공개키 증명서에서 꺼낸 공개키로 암호화된다.
6. 클라이언트는 Change Ciper Spec 메세지를 송신한다. 이 메세지는 이 메세지 이후 통신은 암호키를 사용하여 진행한다는 것을 나타낸다.
7. 클라이언트의 Finished 메세지를 송신한다. 이 메세지는 접속 전체의 체크 값을 포함하고 있다. Negotiation이 성공했는지 어떤지는 서버가 이 메세지를 올바르게 복호화 할 수 있는지 아닌지 결정한다.
8. 서버도 마찬가지로 Change Cipher Spec 메세지를 송신한다.
9. 서버에도 마찬가지로 Finished 메세지를 송신한다.
10. 서버와 클라이언트의 Finished 메세지 교환이 완료되면 SSL에 의해 접속은 확립된다. 이제부터 애플리케이션 계층의 프로토콜에 의해 통신이다. 즉 HTTP 리퀘스트를 송신한다.
11. 애플리케이션 계층의 프로토콜에 의한 통신이다. 즉 HTTP 리스폰스를 송신한다.
12. 마지막에 클라이언트가 접속을 끊는다. 접속을 끊을 경우 `close_ontify` 메세지를 송신한다.



## 네트워크 기본 규칙 및 개념

1. [OSI 7 Layer](#OSI-7-LAYER)
2. [TCP/IP](#TCP/IP)
3. [IP](#IP)
4. [BroadCast, MultiCast, UniCast](#BroadCast,-MultiCast,-UniCast)





### OSI 7 Layer

통신의 접속부터 완료까지의 과정을 7단계로 나눈 참조 모델.



#### 7 계층: 응용 계층 (Application Layer)

사용자와 가까운 프로그램의 정의가 담긴 프로토콜 (HTTP, DNS, FTP, TELNET)

**파일을 실행할 응용프로그램을 정의한다.**



#### 6 계층: 표현 계층 (Presentation Layer)

데이터 포맷을 일관적으로 상호변환, 압축, 암호화 기능을 수행한다. (JPG, JPEG, PNG)

**서로간의 확장자를 확인하고, 표현 방식을 정의한다.**



#### 5 계층: 세션 계층 (Session Layer)

프로그램을 열면 세션 번호가 생성되고, 사용자간 혹은 C/S간의 **송수신권을 형성한다.**



#### 4 계층: 전송 계층 (Transport)

종단간 신뢰성있고 정확한 데이터 전송을 담당한다.

단위는 **Segment**이며 종단간 에러복구와 흐름제어를 담당한다.

L4 스위치는 3계층에서 온 트래픽을 분석하여 서비스의 종류를 구분해주는 역할을 한다.



#### 3 계층: 네트워크 계층 (Network Layer)

발신지와 목적지를 가지고 경로를 선택해 컴퓨간의 연결을 수행해주는 계층이다.

경로선택(라우팅), 논리적 주소정의 계층, 중계기능 가지고있다.

Logical Address(IP)를 사용하여 목적지를 판단한다.

이 과정에서 사용되는 단위는 **Packet**이다.



#### 2계층: 데이터링크 계층 (Data-Link Layer)

물리적인 연결을 통하여 인접한 두 장치간의 신뢰성 있는 정보 전송을 담당한다.

이 과정에서 사용되는 단위는 **Frame**입니다.



#### 1 계층: 물리 계층 (Physical Layer)

두 컴퓨터간 전기적, 기계적 절차적 연결을 정의하는 계층이다.

---

### 계층화의 개념과 장점

계층이 분리되면서 복잡한 개념과 프로토콜이 작은 부분으로 쪼개어지며 하드웨어와 소프트웨어에 적용하거나 문제 해결이 용이해졌고, 이에 대해 논의하기도 쉬워졌다.

---

### TCP/IP

#### Application Layer

**프로토콜인 HTTP, FTP, SMTP, Telnet** 등의 애플리케이션을 제공한다.



#### Transfer Layer

프로그램간의 통신을 책임진다. 프로그램간 정확한 통신을 위해 사용된다.

**프로토콜은 UDP, TCP**가 존재한다. **사용 주소 체계는 Port Address**이다.



#### Internet Layer

컴퓨터와 컴퓨터의 통신, 사용프로토콜은 ARP, IP, ICMP, IGMP이다.

**사용 주소 체계는 32bit의 IP Address**



#### Network Interface Layer

**TCP/IP**패킷을 전달하고 받는 역할이다. 특정 프로토콜이 없다.

**사용 주소 체계는 48bit의 MAC Address**이다.



---

### IP (Internet Protocol)

1. **TCP/IP**에서 사용하는 전송 매커니즘
2. **신뢰성 없는 비 연결형 데이터그램 프로토콜**, 오류 검사 및 흐름제어를 하지 않는다.
3. **Best effort**전달 (오류검사나 추적을하지 않는다.) 이는 최선을 다해 '전달'만 한다.
4. **오류 검사 및 추적 기능을 수행하지 않음**
5. **각 데이터그램은 독립적으로 처리**한다.



**또 하나의 특징이 바로 Fragmentation이다. 즉, 분할이다.**

각 프로토콜은 종류별로 **MTU(Maximum)**가 틀리다.

**MTU(Maximum Transmission Unit)**은 최대 전송할 수 있는 양을 말한다.

이더넷은 **1,500**이다.

PPP: 296

Token Ring (16M): 17,914

따라서 패킷의 크기가 4,000이라고한다면 각 프로토콜별로 그 크기에 맞게 잘라야한다.

가장 많이 쓰는 프로토콜은 IP이기때문에 따라서 1,500의 IP Datagram으로 Fragmentation해야한다.

헤더가 붙기때문에 1,500의 데이터를 전부 포함하지는 않는다.

헤더에 포함되는 정보는 아래와 같다.

- VER(4bit): v4, v6이 존재한다.

- HLEN(4bit): 헤더 전체의 길이를 나타낸다.

- Service Type(8bit): 데이터그램의 전송순위를 나타낸다. **QoS**를 위한 필드이다.

  - 앞의 3비트는 우선순위(QoS), IPv4에는 사용되지 않는다.
  - Type of Service는 4bit이다.
  - 마지막 1비트는 사용되지 않는다.

- Total Length(16bit): 말 그대로 전체 길이이다.

- Identification(16bit): **fragmentation이 일어났을 경우 각 Datagram을 위한 일련번호**, 같은 데이터의 경우 같은 일련번호를 가진다.

- Flag(3bit):  첫 비트는 사용하지 않는다.

  - 두번째 비트는 Fragmentation의 가능 여부를 나타낸다.
  - 세번째 비트는 수신해야할 Datagram이 남아있는 여부를 나타낸다.

- Fragmentatioin Offset: **Fragmentation이 일어났을 때 이것이 몇번째 단편인가 하는 것을 나타낸다.** **Identification**은 단편들이 모두 같은 종류의 데이터를 자른 단편이라는 것을 알려주고 이는 몇번째 단편인지 알려주는 것이다.

- Time of Live: Datagram의 수명이다. 이것이 0이 되면 ICMP가 송시지에 메지를 보내고 데이터그램은 폐기된다.

- Protocol: 이것은 IP계층의 서비스를 사용하는 상위 계층의 프로토콜을 나타낸다.

  ICMP, IGMP, UDP, TCP, OSPF가 있다.

- CheckSum: **오류 검출을 위한 필드이다.**

- Source/Destination Address: **출발지와 도착지 IP 주소**

---

### BroadCast, MultiCast, UniCast

현재 네트워크에서 가장 많이 사용되는 것은 **UniCast**이다.

정확하게 받는 사람의 위치를 알고 통신하는 방식이다. 유니 캐스트를 뿌리게되면 로컬 네트워크상의 모든 PC는 프레임을 받고 자신의 MAC주소와 비교하게된다. 그 후 자신의 것이 아니면 버리게된다.

두번째로 Broadcast, 로컬 랜 상의 모든 사람에게 보내는 방식이다. 상대방과 통신하고 싶을 때 상대방의 MAC 주소를 모를 때 ARP를 동작시킬 때 브로드캐스트가 발생한다.

마지막으로 Multicast, 특정한 그룹에게만 프레임을 보낸다. 이는 라우터나 스위치에서 기능을 지원해줘야만한다. 지원하지 않을경우 브로드캐스트처럼 취급된다.

