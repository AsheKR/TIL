# 순열 (Permutation)



__순서__있게 나열하는 것

순서를 고려하기 때문에 `(1, 2)`와 `(2, 1)`은 서로 다른것

서로다른 n개에서 r(0 < r <= n)개를 택하여 일렬로 나열하는 것을 n개에서 r개를 택하는 __순열__이라고한다.

기호로 `nPr`로 나타낸다.



### 예제

1, 2, 3의 번호가 적힌 3장의 카드 중 서로 다른 2장의 카드를 택하여 만들 수 있는 두자리 자연수의 개수를 구해보자.

첫번째 카드로 선택할 수 있는 것은 3개, 두번째 카드로 선택할 수 있는 것은 2개이므로

`3 * 2 = 6`가지가 나온다. 이를 순열 기호로 나타내면 `3P2`로 나타낸다.



### 개념 2

서로다른 n개에서 r개를 택하는 순열의 수는

`nPr = n*(n - 1) * ... (n - r + 1)`이다.

(단, 0 < r <= n)



#### 예

`A B C D E` 5개의 카드 중에서 3개를 선택한다고 가정할 때

첫번째 카드로 선택할 수 있는 것은 5개, 두번째 카드로 선택할 수 있는 카드는 4, 마지막은 3개이다.

`5P3`으로 나타내며 `5 * 4 * 3`이 된다. 이를 식으로 나타내면 위의 `(n*(n - 1) * ... (n - r + 1))`의 식이 된다.



### 개념 3

`nPr`의 계산을 알아본다.

1. `nPn`의 경우 `n!`의 결과와 같다.
2. `0! = 1`, `nP0 = 1`
3. `nPr = n! / (n - r)!`



#### 2번의 경우

`nPn`의 경우 3번식에 대입하면 `n! / 0!`이된다. 만약 `0!`이 0이라면 0값이 되므로 1로 하여 3번식을 사용할 수 있게 한다.

`nP0`의 경우 3번식에 대입하면 `n! / n!`은 1이되므로 정의된 개념이다.

#### 3번의 경우

`nPr = n * (n - 1) ... (n - r + 1)`의 우항의 분자를 `n!`로 만들기위해 `(n-r) * (n-r-1) ... * 1`까지 아래 위로 곱한다.

그렇게되면 `n * (n - 1) ... (n - r + 1) * (n-r) * (n-r-1) ... * 1 / (n-r) * (n-r-1) ... * 1`이되고 이를 해석하면 `n! / (n-r)!`이 된다.



## 구현 방법

`{a, b, c, d}`의 모든 순열을 나열하라고 했을 때

- `{b, c, d}`의 모든 순열에 `a`를 추가하여 출력하고
- `{a, c, d}`의 모든 순열 `b`를 추가하여 출력하고
- ...

이렇게 모두 출력하면 가능하다.



```python
# S의 순열들을 생성하고 각각의 Prefix String을 앞에 붙여 출력한다.
def printPerm(prefix_string, S):
    if S is empty:
        print prefix_string
    else:
        for each element x in S:
            printPerm(the prefix_string + x, S-{x})
```



```python
data = ['a', 'b', 'c', 'd']
n = 4

# S를 사용하지 않는 이유는 전역변수로 사용하기 때문
def perm(k):
    if k == n:
        print data
        return
   	for i in range(k, n):
        # data의 순서를 보장해야한다.
        swap(k, i)
        perm(k + 1)
        swap(k, i)
```

