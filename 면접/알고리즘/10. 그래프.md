# 그래프



## 그래프의 개념과 표현



`G = (V, E)`로 표현되며

`V`는 Vertex, 노드 혹은 정점

`E`는 Edge, 노드쌍을 연결하는 엣지 혹은 링크



특별한 언급이 없는 이상 노드의 개수를 n, 엣지의 개수를 m으로 표현한다.



### 그래프의 종류

- **방향을 고려하지 않는 무방향 그래프**
- **방향을 고려한 방향 그래프**
- 그래프의 모든 `E`가 `가중치(weight)`를 가지는 가중치 그래프가 존재한다.



### 그래프의 표현

- **인접행렬(adjacency matrix)**

인접행렬은 그래프를 `n*n`의 행렬로 표현하는 방법이다.

인접행렬 방법에서, i번째 행 j번째 열을 Aij이라고 할때

정점 i, j 사이에 엣지가 있으면 1, 없으면 0으로 표시한다.



예를 들어, 1과 2 사이에 엣지가 있으므로 1행 2열의 값은 1이된다.

마찬가지로 3과 4 사이에 엣지가 없으면 3행 4열의 값은 0이 된다.



결과적으로 모든 행렬을 완성했을 때 대칭 행렬의 구조를 가지는데,

여기서 대칭 행렬이라는 뜻은 대각을 기준으로 접었을 때 대칭이라는 뜻이다.





그래프에서 가장 기본적인 연산은 해당 노드에 인접한 노드를 찾는 연산이다. 

인접 노드를 찾기 위해서, 인접 행렬의 한 행 전체를 끝까지 읽는 방법이 있다. 해당 행에서 1의 값을 가지고 있는 열이 인접한 노드이므로, 인접하는 노드를 찾으려면 `O(n)`의 시간 복잡도를 가진다.

두번째로 중요한 연산은, 두 노드 `u`와 `v`를 연결하는 엣지가 있는지 확인하는 것이므로, `u`행 `v`열의 값만 보면 되므로 `O(1)`의 시간 복잡도를 가진다.



인접 행렬에서의 가중치는 엣지의 존재를 나타내는 1 대신 가중치로 표현한다.



- **인접 리스트(adjacency list)**

인접 리스트에서는 배열 하나가 각각의 노드를 표시한다.

그리고 나서 해당 노드에 인접한 노드들을 연결리스트의 형태로 연결한다.

인접한 노드를 찾기위해 인접 리스트에서는 해당 노드에 연결 리스트의 길이 만큼의 시간이 필요하다.

이 때, 어떤 노드 v에 실제로 인접한 노드의 개수는 `degree(v)`라고 부른다.

따라서 `O(degree(v))`의 시간 복잡도를 가진다.

둘째로 어떤 에지 `(u, v)`가 존재하는지 검사하기위해 모든 리스트를 찾아봐야하므로 

`O(degree(u))`의 시간 복잡도를 가진다.

