# Hash Table

- dynamic set을 구현하는 효과적인 방법의 하나
  - 적절한 가정하에 평균 탐색, 삽입, 삭제시간 `O(1)`
  - 최악의 경우 `O(n)`



## Collision

- 두 개 이상의 키가 동일한 위치로 해슁되는 경우
- 해쉬로 나온 함수가 정의역보다 크지 않기 때문에 항상 발생 가능 (즉, 단사 함수가 아님)

- 해결방법 **chaining**과 **open addressing**



### Chaning에 의한 충돌 해결

동일한 장소로 해생된 모든 키들을 하나의 연결리스트로 저장



- 키의 삽입
  - 키 k를 리스트 Table[h(k)]의 맨 앞에 삽입: 시간복잡도 `O(1)`
  - 중복 저장이 허용되지 않는다면 삽입시 리스트를 검색해야함. 따라서 시간 복잡도는 리스트의 길이에 비례
- 키의 검색
  - 리스트 Table[h(k)]에서 순차검색
  - 시간복잡도는 키가 저장된 리스트의 길이에 비례
- 키의 삭제
  - 리스트 Table[h(k)]로부터 키를 검색 후 삭제
  - 키를 검색해서 찾은 후에는 `O(1)`에 삭제



- 최악의 경우는 모든 키가 하나의 슬롯으로 해싱되는 경우
  - 길이가 n개인 하나의 연결리스트가 만들어짐
  - 따라서 최악의 경우 탐색시간은 `O(n) + 해시함수 계산시간`
- 평균 시간 복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해 결정



#### SUHA (Simple Uniform Hasing Assumption)

각각의 키가 모든 슬롯에 대해 균등한 확률로 독립적으로 해싱된다는 가정이다.

성능 분석을 위한 가정이므로 현실에서는 불가능하다.



각 슬롯에 저장되는 키의 평균 개수를 `Load factor`라고 했을 때

`Load factor = a = n/m`

`n : 테이블에 저장될 키 개수`

`m: 해시 테이블의 크기, 즉 연결 리스트의 개수`





연결리스트 `T[j]`의 길이를 `nj`라고 하면 `E[nj] = a`

만약 `n=O(m)`이면 평균 검색 시간은 `O(1)`이다. 



### Open Addressing

해시 테이블에 슬롯에 키는 하나씩만 저장되고

충돌이 일어나면 다른 슬롯에 저장하는 방식이다.



#### Linear Probing

`h(k)`에 충돌이 발생했을 때 연속적으로 이어져있는 부분 중 비어있는 인덱스 `h(k + n)`에 저장하는 방식이다.

이 인덱스가 테이블의 끝에 들어가면 다시 처음으로 순환하여 돌아온다.



**단점은** **클러스터링**이다.

테이블의 키들이 연속적으로 뭉쳐있는 것을 **클러스터링**이 심하다고 하는데,

긴 클러스터가 생길수록 새 키가 삽입될 때 결과가 클러스터 끝으로 해싱될 확률이 점점 높아진다.



#### Quardratic probing

위의 Linear Probing의 단점을 보완하기 위해 만들어졌다.

probing의 순서를 조금 변경한것으로 충돌 발생시 다른 수식으로 해싱을 시도한다.

`h(k), h(k) + 1, h(k) + 2^2, h(k) + 3^2`

이 방법도 테이블을 순환하며, 수식은 달라질 수 있다.

클러스터링이 심해지는 것은 피할 수 있지만 다른 단점도 존재한다.

초기 해시값이 같으면 다음 탐사 위치 또한 동일하기 때문에 효율성이 떨어진다.



#### Double Hashing

기본적인 개념은 Quardratic probing과 비슷하게 클러스터링을 줄이기위해 띄엄띄엄 저장한다.

처음부터 해시 함수 2개를 만들게 된다.

`h(k, i) = (h_1(k) + i * h_2(k)) mod m`



## 좋은 해시 함수

해시함수의 값이 불규칙적이 되도록하는 것이 바람직하다.

즉, 해시 함수의 값이 키의 특정 부분에 의해 결정되지 않도록 해야한다.

그래서 대부분의 해시함수를 구현할 때 사용하는 연산들이 위와 같은 목적을 가지고 이루어지게된다.



#### Division 기법

키를 테이블 사이즈로 나누어 나머지를 구하는 연산이다.

`h(k) = k mod m`

이 방법은 한번의 mod 연산으로 매우 빠르다.

단점은, 어떤 m값에 대해 해시 함수값이 키 값의 특정 부분에 의해 결정되는 경우가 있다.



#### multiplication 기법

- 0에서 1사이의 상수 A를 선택 
- K*A의 소수 부분만을 선택
- 소수 부분에 m을 곱한 후 소수점 아래를 버린다.



`m=8, word size = w = 5, k = 21`

1. `A = 13 / 32`
2.  `k * A = 21 * 13 / 32 = 8 * 17/ 32`
3. `m(k_a mod 1) = 8 * 17 / 32 = 17 / 4 = 4.~~~`
4. `h(21)`은 4가된다.