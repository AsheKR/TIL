# 면접 때 들은 질문!
 ## nginx(Web Server), uwsgi(WSGI), Django(WAS) 역할
 
 ### Web Server
 HTTP 요청을 받아 HTML와 같은 웹페이지를 반환하는 서버, 주로 정적인 컨텐츠를 처리한다.
 
 ### WAS(Web Application Server)
 **동적 서버 콘텐츠**를 수행한다는 것으로 Web Server와 구별되며, 주로 데이터베이스 서버와 같이 수행된다.
 
 **WEB 서버의 기능을 구조적으로 분리하여 처리하고자하는 목적으로 제시된 것**
 
 ### WSGI (Web Server Gateway Interface)
 web server와 Python으로 작성한 web application 또는 Framework 들간의 인터페이스를 정의해둔 규칙이다.
 
 #### 왜 탄생했을까?
사용자가 파이썬으로 작성된 web application framework의 선택이 web server의 선택의 제한을 두게 되었다. 물론 그 반대로 web server의 선택이 web application framework의 선택에 제한을 두게 되었다. 그 이유는 web application이 특정한 하나의 API, 예를들어 CGI, FastCGI, mod_python 를 지원하게끔 만들어졌기 때문이다.
 
 #### uWSGI만으로도 서버를 제공할 수 있는데 왜 nginx를 쓸까?
 nginx와 같이 써서 얻는 가장 큰 이점은 향상된 Static Content(Css, Javascript) 핸들링을 통해 서버에 발생되는 부하를 줄일 수 있다.
 
 
 ## 프레임워크와 라이브러리의 차이
 이 둘을 구별하는 것은 **누가 누구를 호출하느냐(who calls who)** 의 차이이다.
 
 프레임워크에서는 __프레임워크 코드__ 가 __내 코드__ 를 호출하고 (In a framework, the framework code calls on your code.)
 
 라이브러리에서는 __내 코드__ 가 __라이브러리__ 를 호출한다. (In a library, it is your code that makes calls to the library.)
 
 또한 제어에 관한 것이다.
 
 프레임워크는 나의 애플리케이션의 흐름을 통제하고, 라이브러리는 그렇지 않다.
 
 ## Request-Response LifeCycle
 ![LifeCycle](https://external-preview.redd.it/P53_07QnF2IBiXbEYCRb2LgU6moj-h6ZFCvZHFzBMtQ.png?auto=webp&s=9bbaf0e3c46d6ee7c44f6d50268eff40e3a29d89)
 1. Request Middleware
 2. URL Resolution (urls.py)
 3. Views Middleware
 4. Views (views.py)
 5. Template Middleware
 6. Template (example.html)
 7. Response Middleware
 
 # Interview_Quuestion_for_Beginner

[링크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)

## 개발 상식

### 객체 지향 프로그래밍

컴퓨터 중심 사고에서 벗어나 인간중심 사고적으로 프로그래밍하는 것이다.
현실 사물을 객체라 보고 그 객체로부터 개발하고자하는 특징을 뽑아 프로그래밍 한다.
주로 사용되는 로직을 라이브러리로 만들어 사용하면 코드 재사용성, 신뢰성, 생산성이 높다.

#### 객체지향적 설계 원칙

1. SRP(Single Responsibility Principle) : 단일 책임의 원칙
	클래스는 단 하나의 책임을 가져야하며 클래스의 변경 이유는 단 하나의 이유여야 한다.
2.  OCP(Open-Closed Principle): 개방-폐쇠의 원칙
	확장에는 열려있고 변경에는 닫혀있어야한다.
3.  LSP(Liskov Substitution Principle): 리스코프 치환 원칙
	상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle): 인터페이스 분리의 원칙
	인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5.  DIP(Dependency Inversion Principle): 의존 역전 원칙
	고 수준 모듈은 저 수준 모듈의 구현에 의존해서는 안된다.

### RESTful API
REpresentational State Tranfer
API 설계의 중심에 자원이 있고 HTTP Method를 통해 자원을 처리하도록 설계한다.

#### RESTful 하게 API를 디자인
1. 리소스와 행위를 명시적이고 직관적으로 분리한다.
	- URI로 표현되는 리소스는 명사로 표현되야한다.
	- 행위는 HTTP Method로 표현하고 `GET,POST,PUT,PATCH,DELETE`를 분명한 목적으로 사용한다.
2. Message는 Header, Body를 명확하게 분리해서 사용한다.
	- Entity에 대한 내용은 Body에 담는다.
	- 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, MIME 타입 등은 header에 담는다.
3. API 버전을 관리한다.
	- 환경은 항상 변하기 때문에 API의 signature가 변경될 수 있음에 유의하자.
	- 특정 API를 변경할 때는 반드시 하위호환성을 보장해야한다.
4. 서버와 클라이언트가 같은 방식을 사용해 요청하도록한다.
	- 어떤 방식으로 데이터를 보내든 하나도 통일한다.

#### 장점
1. Open API를 제공하기 쉽다.
2. 멀티 플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

#### 단점
1. 사용할 수 있는 메서드가 4가지 밖에 없다.
2. 분산환경에 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.

### TDD

- 일반적 개발 프로세스
	디자인 -> 코드 작성 -> 테스트
- TDD
	RED -> GREEN -> REFACTOR

	정확한 프로그래밍을 목적으로 디자인 단계에서 반드시 미리 테스트를 작성해야한다.
	RED: 실패하는 테스트를 만들기
	GREEN: 테스트에 통과할만한 작은 코드 작성
	REFACTOR: 반복되는 코드, 긴 메서드, 큰 클래스, 긴 매개변수 목록 등 코드를 좀 더 효율적으로 변경

매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스.
모든 사용자 스토리, 사용자 케이스를 테스트하는 코드를 작성하여 나중에 코드를 변경 할 일이 생길 때 기존 기능의 오작동을 빠르게 알고 처리할 수 있다.

### MVC, MTV

#### MVC
**Controller(컨트롤러)**
요청을 받으면 모델 컴포넌트를 호출하고 모델에 전달하기 쉽게 데이터를 가공한다.

**Model (모델)**
비즈니스 로직이 실행되는 부분

**View(뷰)**
컨트롤러부터 받은 결과값을 가지고 출력할 화면을 만든다.

#### MTV
**Model(모델)**
MVC의 Model

**Template(템플릿)**
MVC의 View

**View(뷰)**
MVC의 Controller

## Algorithm
1. Bubble Sort
	Performance: O(n^2)
	Space Complexity: O(n)

2. Selection Sort
	Performance: O(n^2)
	space complexity: O(n) total, O(1) auxiliary

3. Insertion Sort
	Performance: if already sorted O(n)
		     else O(n^2)
	space complexity: O(n) total

4. Merge Sort
	Performance: O(log n)
	space complexity: O(2n)

5. Quick Sort
	Performance: O(n^2) ~ O(n log2 n)
	space complexity: O(n)

## DataStructure

### Array
#### 특징
논리적, 물리적 저장 순서가 일치한다.

#### 단점
중간 삽입, 삭제 과정이 있을 경우 `shift`에 대한 코스트가 발생한다.

### LinkedList
#### 특징
위 `shift cost`를 해결하기 위한 자료구조
각 원소는 자기 자신 다음에 어떤 원소인지만을 기억한다.

#### 단점
Search시 모든 원소를 확인해야한다.

### Stack
#### 특징
선형 자료구조, `LIFO`

### Queue
#### 특징
선형 자료구조, `FIFO`

### Tree
#### 특징
비 선형 자료구조

#### 용어
- Node: 각 요소
- Edge: 노드간의 연결선
- Root Node: 트리 최상위 요소
- Terminal Node: 하위 노드가 연결되어있지 않은 노드
- Internal Node: 단말 노드를 제외한 노드

### Binary Tree
#### 특징
한 노드가 두개 이하의 서브 노드를 갖는다.

#### 용어
- Level: 루트를 0을 기준으로 아래로 증가
- Degree: 루트를 1을 기준으로 아래로 증가
- Full Binary Tree: 레벨의 요소를 모두 채운 것
- Complete Binary Tree: 위에서 아래로, 왼쪽에서 오른쪽으로 모두 채운 것

### Binary Search Tree
#### 특징
효율적 탐색을 위해 데이터를 저장한 방법

#### 규칙
- 이진 탐색 트리의 노드에 저장된 키는 유일하다.
- 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노트의 키보다 크다.
- 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떤 노드의 키보다 작다.
- 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

#### 단점
편향(Skewed)트리가 될 수 있다.
이를 해결하기위해 `Rebalancing` 기법이 등장했다.

### Binary Heap
#### 특징
최대값 또는 최소값을 빠르게 찾기 위해 고안된 트리 모양의 자료구조
MAX Heap은 최대값, MIN Heap은 최소값을 빠르게 찾을 수 있다.

#### 삽입
1. 완전이진트리의 가장 마지막 원소에 원하는 값을 삽입한다.
2. 부모가 나보다 작으면 부모와 값을 교환한다.
3. 부모가 없거나, 부모가 자식보다 클 경우 교환을 끝낸다.

#### 삭제
1. 루트노드를 heap의 가장 마지막 노드와 교환한다.
2. 교환된 가장 마지막 노드를 삭제한다.
3. 자식노드와 비교 후 가장  큰 값과 교환한다.

### Red Black Tree
#### 특징
`Binary Search Tree`를 기반으로 하는 트리 형식의 자료구조
편향을 줄이기위해 반드시 complete binary tree를 만든다.

#### 원칙
1. 각 노드는 `Red` 또는 `Black`이라는 색을 가진다.
2. 루트노드의 색은 `Black`이다.
3. 각 leaf node는 `black`이다.
4. 어떤 노드의 색이 `red`라면 두 개의 children 색은 모두 `black`이다.
5. leaf node에서 루트노드까지 가는 경로에 만나는 블랙노드의 개수는 같다.

#### 삽입
1. 루트 노드는 검정색
2. 삽입되는 노드는 모두 빨간색
3. 4번 원칙을 위배할 때 해결할 수 있는 방법: `Restructuring`, `Recoloring`

#### `Restructuring` `Recoloring`
삽입된 노드의 uncle node(부모의 자식)의 색에 따라 수행하는 프로시저가 다르다.
uncle node가 검정일 때 `Restructuring`
uncle node가 빨강일 때 `Recoloring`을 수행한다.

#### `Restructuring`
`삽입된 노드`와 `부모`와 내 `부모의 부모`를 가지고 `Restructuring`을한다.

1. 위 세개를 오름차순 정렬
2. 무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.
3. 올라간 가운데 있는 값을 검정으로 만들고 그 두 자식을 빨강으로 만든다.

#### `Recoloring`

1. `삽입된 노드`의 `부모`와 그 `부모의 형제`를 검정으로 하고 `부모의 부모`를 빨강으로 한다.
2. `부모의 부모`가 루트 노드가 아니었을 시 4번원칙을 위배할 수 있다. `부모의 부모`가 루트 노드일 시  검정색으로 한다.

### HashTable
#### 특징
Key: Value를 저장하는 데이터 구조로 
**특별한 알고리즘**을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만든 후 이를 인덱스로 사용한다.

#### Resolve Conflict
1. Open Address
충돌이 발생하며 다른해시 버킷에 해당 자료를 삽입한다.
	1. Linear Probing
		순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.
	2. Quadratic probing
		2차 함수를 이용해 탐색할 위치를 찾는다.
	3. Double hashing probing
		하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬함수를 이용해 
		새 주소를 할당한다. 위 두개 방법에비해 많은 연산량을 요구한다.

2. Separate Chaning
해시충돌이 나지 않도록 보조 해시 함수를 사용하는 것
	- 연결리스트를 사용하는 방법
		각각의 버킷을 연결리스트로 만들어 충돌이 발생하면 해당 bucket의 list에 추가하는 방식이다. 작은 데이터들을 저장할 때 연결리스트 자체의 오버헤드가 부담이 된다.
	- Tree를 사용하는 방법

데이터의 개수가 적을 때는 연결리스트, 데이터의 개수가 많을 때는 트리를 사용한다.
키-값 쌍의 개수가 6개, 8개를 기준으로 결정한다.

### Graph

#### 용어
정점
간선
Degree: 각 정점에서 연결된 Edge의 개수

#### 구현방법
인접행렬: 정방행렬을 사용, Dense graph를 사용할 때 적절하다.
인접리스트: 연결리스트를 사용 Sparse graph를 사용할 때 적절하다.

#### 그래프 탐색
깊이우선탐색
임의의 한 정점으로부터 연결되어 있는 한 정점으로 나아간다라는 방법을 우선으로 탐색한다. Stack을 사용
너비우선탐색
Tree의 Level Order Traversal 형식으로 진행된다. Queue를 사용

## Network

### HTTP, GET, POST
#### GET
`HTTP Request Message`의 Header 부분에 url에 담겨서 전송된다.
데이터 크기 또한 제한적이다. url이 노출되므로 보안상 적절치 않다.
브라우저가 캐싱 가능하다.

#### POST
`HTTP Request Message`의 Body 부분에 데잍가 담겨 전송된다.
데이터 크기가 제한되지 않고 GET 방식보다 보안면에서 낫다.

### 3-way-handshake

#### Connection Establishment
[링크](http://asfirstalways.tistory.com/356)

### TCP, UDP

#### UDP
비 연결형 프로토콜
흐름제어, 오류제어, 손상된 세그먼트 수신에 대한 재전송을 하지 않는다.

#### TCP
신뢰성, 순차적 전달
전 이중, 점대점

### HTTP, HTTPS

#### HTTP의 문제점
- 평문 통신
- 통신 상대를 몰라 위장이 가능
- 완전성을 증명할 수 없기때문에 변조가 가능

#### 보안방법
- 통신 자체를 암호화(SSL, TLS), 콘텐츠를 암호화(HTTP 메세지의 콘텐츠만)
- 증명기관을 이용

SSL/TLS의 주요 기능
- 상호 인증, 메세지 압축, 메세지 인증, 암호화용 세션 키, 비밀키에 의한 암호화된 종단간 안전한 연결 제공

#### HTTPS
SSL을 사용한 HTTP
HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게된다.

### 웹 통신의 흐름
1. 브라우저가 URL을 조사
2. HTTP Request 메세지를 생성
3. 프로토콜 스택(운영체제 내 네트워크 제어용 소프트웨어)가 메세지를 받음
4. 패킷 속에 저장하고 제어 정보를 덧붙임
5. 패킷을 LAN 어댑터로 넘김
6. 전기신호로 변환 후 송출
7. 스위칭 허브를 통하여 인터넷 접속용 라우터에 도착
8. 패킷을 ISP 라우터로 전송
9. 인터넷에 들어감
10. 액세스 회선에 의해 POP(Point of Presence, 통신사용 라우터)까지 운반됨 
11. POP로 거쳐 인터넷의 핵심부로 들어감
12. 라우터를 흘러 목적지로 도착
13. 웹 서버의 LAN으로 도착
14. 도착한 패킷을 검사하여 방화벽 및 캐시서버를 사용하여 Response해줄지 검사
15. 물리적 웹 서버에 도착하면 패킷을 추출하여 메세지를 복원 후 웹 서버 애플리케이션으로 넘김
16. 메세지를 받은 웹 서버 애플리케이션은 요청 메세지에 따른 데이터 응답 메세지를 넣어 클라이언트로 회송
17. 왔던 방식으로 메세지가 클라이언트에게 전달됨

# 운영체제

## 프로세스와 스레드

### 프로세스
디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다.
PCB는 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조이다.
프로세스 전환이 발생했을 때 진행 작업을 저장하고 CPU를 반환해야하므로, PCB에 저장하게된다.

### 스레드
프로세스 안에서 실행되는 흐름의 단위
프로세스가 할당된 자원을 함께 공유하면서 작업을 처리한다.

#### 멀티 스레드
한 프로세스를 다수의 실행 단위, 즉 다수의 스레드로 구분하여, 여러 스레드가 독립적으로 작업을 병렬로 처리할 수 있는 방법이다.
동시에 처리하는 것이 아닌 여러 스레드가 독립적으로 처리하는것일 뿐이다.


## CPU 스케줄러

### FCFS
### SJF
### SRT
### RR

## 동기와 비동기
### 동기
설계가 매우 간단하고 직관적이지만, 결과가 주어질 때까지 아무것도 못하고 대기해야하는 단점
동기보단 복잡하지만, 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다.

## 메모리 관리 전략
### Swapping
메모리 공간이 부족할 때 사용되는 저략
CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 보내고 다른 프로세스의 메모리를 불러들일 수 있다.
### Fragmentation
프로세스들이 차지하는 메모리 틈 사이의 자유공간
- 외부 단편화: 물리 메모리 사이에 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산
- 내부 단편화: 프로세스가 사용하는 메모리 공간에 포함된 남는 부분
이를 해결하기 위해 통합, 압축 기법이 나옴
- 통합: 사용중에 통합이 가능,  공간이 인접된 것을 사용
- 압축: 떨어진 공간의 공간도 합칠 수 있으며 사용하면서 압축은 불가하다.
### Paging
하나의 프로세스가 사용하는 메모리 공간이 연속적이여야 한다는 제약을 없애는 메모리 관리 방법
외부 단편화는 해결할 수 있지만 내부 단편화가 생길 수 있다.

### 가상 메모리
프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

# 데이터베이스

## 사용하는 이유
과거 파일 시스템을 사용하여 데이터를 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야한다. 이 때 문제점은 **종속성** 문제와 **중복성**, **무결성**이다.

## 데이터베이스의 특징
1. 데이터의 독립성
	- 물리적 독립성: 데이터베이스를 변경하여도 애플리케이션을 수정할 필요는 없다.
	- 논리적 독립성: 데이터베이스는 논리적 자료구조로 다양한 응용프로그램의 논리적 요구를 만족시킬 수 있다.
2. 데이터의 무결성
3. 데이터의 보안성
	- 인가된 사용자만이 데이터베이스나 데이터베이스 내 자원에 접근할 수 있도록 접근권한설정이 가능하다.
4. 데이터의 일관성
	- 연관된 정보를 논리적인 구조로 관리함으로서 데이터의 불일치성을 배제할 수 있다.
5. 데이터 중복의 최소화
	- 통합관리로 중복의 문제를 해결할 수 있다.

## 데이터베이스의 성능
성능 이슈는 **디스크I/O**를 어떻게 줄이느냐의 문제이다.
순차 I/O가 랜덤 I/O보다 빠르기 때문에 쿼리 튜닝은 랜덤I/O 자체를 줄여주는것이 목적이다.

## index

### 정의
정렬된 상태로 저장되길 원할 때 index를 사용한다.
저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높일 수 있다.

### 자료구조
#### B+ Tree Index
이 자료구조는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 기법이다.

#### Hash Index
칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
값의 일부의 검색에는 해시 인덱스를 사용할 수 없다. `=` 연산에 특화되어 메모리 기반의 데이터베이스에서 주로 사용한다.

### Index의 성능과 고려사항
한 컬럼에 대해 인덱스를 생성하면 INSERT, DELETE, UPDATE 쿼리문에도 별도의 추가 과정이 필요하다.
다양한 결과가 컬럼에 들어가는 곳에 인덱스를 생성하는 것이 효율적이다.

## 정규화

### 탄생배경
`갱신 이상`발생을 최소화하기위해 정규화하는 것이다.

### 정규화
관계형 데이터베이스에서 중복을 최소화하기위해 데이터를 구조화하는 작업이다.
```
1차 정규화 - 원자 값이 아닌 도메인을 분해
2차 정규화 - 부분함수 종속을 제거
3차 정규화 - 이행함수 종속을 제거
BCNF 정규화 - 결정자 후보키가 아닌 함수 제거
4 정규화 - 함수종속이 아닌 다치 종속을 제거
5 정규화 - 후보키를 통하지 않은 JOIN 종속 제거
```

#### 장점
1. 이상 현상 제거
2. 구조 확장시 재 디자인 최소화
3. 사용자에게 데이터 모델을 더욱 의미있게 제공

#### 단점
JOIN 연산이 많아진다.

## 트랜잭션

작업의 **완전성**을 보장해주는 것.
논리적 작업셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우 원 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.

### 트랜잭션과 LOCK
LOCK은 동일 자원을 요구할 경우 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

### 트랜잭션의 특성
`ACID`
1. 원자성 (Atomicity) - 모두 성공하거나 모두 작업하지 않아야 한다.
2. 일관성(Consistency) - 데이터의 일관성을 보장해야한다.
3. 고립성(Isolation) - 각각의 트랜잭션은 간섭하면 안된다.
4. 지속성(Durability) - 트랜잭션이 정상적으로 종료된 다음 영구적으로 데이터베이스 작업의 결과를 저장해야한다.

### 상태
1. Active - 트랜잭션 실행상태
2. Failed - 트랜잭션 실패상태
3. Partial Committed - 트랜잭션의 `Commit` 명령이 도착한 상태, SQL문이 수행된다.
4. Committed - 트랜잭션 완료상태
5. Aborted - 트랜잭션 취소 상태, 이전 데이터로 돌아간 상태

#### Partial Committed, Committed
`Commit` 요청이 들어오면 상태는 `Partial Committed` 상태가 된다.
이 후 `Commit`을 문제 없이 수행하면 `Committed` 상태로 전이되고, 오류가 있다면 `Failed` 상태가 된다.

### 주의점
트랜잭션 범위를 최소화 하여야한다.
일반적으로 데이터베이스 커넥션의 개수는 제한적이다.

## NoSQL

RDBMS에서 데이터 일관성과 중복 최소화를 위해 `SCHEMA`를 구성할 때, 여러 테이블로 나누어 구성한다.
따라서 데이터를 많은 수의 서버로 분산하여 나누는 `data sharing`을 지원하는 것이 어렵다.
이를 극복하기 위한 것이 `NoSQL`

### 장점
서버 확장성을 위해 가급적 테이블을 쪼개지 않고 큰 테이블에 모두 담아 저장한다.
저장 시 `KEY, VALUE`형식을 사용하여 데이터 저장의 유연성을 얻는다.

### 단점
`Join, Indexing`이 불가해 다양하고 복잡한 데이터 쿼리는 불가하다.
단순 `READ, WRITE`에 특화되어있다.
데이터의 궁극적 일관성(Eventual Consistency)은 지원하되 여러 서버에 동기화인 즉각 일관성은 지원하지 못한다.
