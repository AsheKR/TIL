# Interview_Quuestion_for_Beginner

[링크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)

## 개발 상식

### 객체 지향 프로그래밍

컴퓨터 중심 사고에서 벗어나 인간중심 사고적으로 프로그래밍하는 것이다.
현실 사물을 객체라 보고 그 객체로부터 개발하고자하는 특징을 뽑아 프로그래밍 한다.
주로 사용되는 로직을 라이브러리로 만들어 사용하면 코드 재사용성, 신뢰성, 생산성이 높다.

#### 객체지향적 설계 원칙

1. SRP(Single Responsibility Principle) : 단일 책임의 원칙
	클래스는 단 하나의 책임을 가져야하며 클래스의 변경 이유는 단 하나의 이유여야 한다.
2.  OCP(Open-Closed Principle): 개방-폐쇠의 원칙
	확장에는 열려있고 변경에는 닫혀있어야한다.
3.  LSP(Liskov Substitution Principle): 리스코프 치환 원칙
	상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle): 인터페이스 분리의 원칙
	인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5.  DIP(Dependency Inversion Principle): 의존 역전 원칙
	고 수준 모듈은 저 수준 모듈의 구현에 의존해서는 안된다.

### RESTful API
REpresentational State Tranfer
API 설계의 중심에 자원이 있고 HTTP Method를 통해 자원을 처리하도록 설계한다.

#### RESTful 하게 API를 디자인
1. 리소스와 행위를 명시적이고 직관적으로 분리한다.
	- URI로 표현되는 리소스는 명사로 표현되야한다.
	- 행위는 HTTP Method로 표현하고 `GET,POST,PUT,PATCH,DELETE`를 분명한 목적으로 사용한다.
2. Message는 Header, Body를 명확하게 분리해서 사용한다.
	- Entity에 대한 내용은 Body에 담는다.
	- 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, MIME 타입 등은 header에 담는다.
3. API 버전을 관리한다.
	- 환경은 항상 변하기 때문에 API의 signature가 변경될 수 있음에 유의하자.
	- 특정 API를 변경할 때는 반드시 하위호환성을 보장해야한다.
4. 서버와 클라이언트가 같은 방식을 사용해 요청하도록한다.
	- 어떤 방식으로 데이터를 보내든 하나도 통일한다.

#### 장점
1. Open API를 제공하기 쉽다.
2. 멀티 플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

#### 단점
1. 사용할 수 있는 메서드가 4가지 밖에 없다.
2. 분산환경에 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.

### TDD

매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스.
모든 사용자 스토리, 사용자 케이스를 테스트하는 코드를 작성하여 나중에 코드를 변경 할 일이 생길 때 기존 기능의 오작동을 빠르게 알고 처리할 수 있다.

### MVC, MTV

#### MVC
**Controller(컨트롤러)**
요청을 받으면 모델 컴포넌트를 호출하고 모델에 전달하기 쉽게 데이터를 가공한다.

**Model (모델)**
비즈니스 로직이 실행되는 부분

**View(뷰)**
컨트롤러부터 받은 결과값을 가지고 출력할 화면을 만든다.

#### MTV
**Model(모델)**
MVC의 Model

**Template(템플릿)**
MVC의 View

**View(뷰)**
MVC의 Controller

## DataStructure

### Array
#### 특징
논리적, 물리적 저장 순서가 일치한다.

#### 단점
중간 삽입, 삭제 과정이 있을 경우 `shift`에 대한 코스트가 발생한다.

### LinkedList
#### 특징
위 `shift cost`를 해결하기 위한 자료구조
각 원소는 자기 자신 다음에 어떤 원소인지만을 기억한다.

#### 단점
Search시 모든 원소를 확인해야한다.

### Stack
#### 특징
선형 자료구조, `LIFO`

### Queue
#### 특징
선형 자료구조, `FIFO`

### Tree
#### 특징
비 선형 자료구조

#### 용어
- Node: 각 요소
- Edge: 노드간의 연결선
- Root Node: 트리 최상위 요소
- Terminal Node: 하위 노드가 연결되어있지 않은 노드
- Internal Node: 단말 노드를 제외한 노드

### Binary Tree
#### 특징
한 노드가 두개 이하의 서브 노드를 갖는다.

#### 용어
- Level: 루트를 0을 기준으로 아래로 증가
- Degree: 루트를 1을 기준으로 아래로 증가
- Full Binary Tree: 레벨의 요소를 모두 채운 것
- Complete Binary Tree: 위에서 아래로, 왼쪽에서 오른쪽으로 모두 채운 것

### Binary Search Tree
#### 특징
효율적 탐색을 위해 데이터를 저장한 방법

#### 규칙
- 이진 탐색 트리의 노드에 저장된 키는 유일하다.
- 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노트의 키보다 크다.
- 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떤 노드의 키보다 작다.
- 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

#### 단점
편향(Skewed)트리가 될 수 있다.
이를 해결하기위해 `Rebalancing` 기법이 등장했다.

### Binary Heap
#### 특징
최대값 또는 최소값을 빠르게 찾기 위해 고안된 트리 모양의 자료구조
MAX Heap은 최대값, MIN Heap은 최소값을 빠르게 찾을 수 있다.

#### 삽입
1. 완전이진트리의 가장 마지막 원소에 원하는 값을 삽입한다.
2. 부모가 나보다 작으면 부모와 값을 교환한다.
3. 부모가 없거나, 부모가 자식보다 클 경우 교환을 끝낸다.

#### 삭제
1. 루트노드를 heap의 가장 마지막 노드와 교환한다.
2. 교환된 가장 마지막 노드를 삭제한다.
3. 자식노드와 비교 후 가장  큰 값과 교환한다.

### Red Black Tree
#### 특징
`Binary Search Tree`를 기반으로 하는 트리 형식의 자료구조
편향을 줄이기위해 반드시 complete binary tree를 만든다.

#### 원칙
1. 각 노드는 `Red` 또는 `Black`이라는 색을 가진다.
2. 루트노드의 색은 `Black`이다.
3. 각 leaf node는 `black`이다.
4. 어떤 노드의 색이 `red`라면 두 개의 children 색은 모두 `black`이다.
5. leaf node에서 루트노드까지 가는 경로에 만나는 블랙노드의 개수는 같다.

#### 삽입
1. 루트 노드는 검정색
2. 삽입되는 노드는 모두 빨간색
3. 4번 원칙을 위배할 때 해결할 수 있는 방법: `Restructuring`, `Recoloring`

#### `Restructuring` `Recoloring`
삽입된 노드의 uncle node(부모의 자식)의 색에 따라 수행하는 프로시저가 다르다.
uncle node가 검정일 때 `Restructuring`
uncle node가 빨강일 때 `Recoloring`을 수행한다.

#### `Restructuring`
`삽입된 노드`와 `부모`와 내 `부모의 부모`를 가지고 `Restructuring`을한다.

1. 위 세개를 오름차순 정렬
2. 무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.
3. 올라간 가운데 있는 값을 검정으로 만들고 그 두 자식을 빨강으로 만든다.

#### `Recoloring`

1. `삽입된 노드` `부모`와 그 `부모의 형제`를 검정으로 하고 `부모의 부모`를 빨강으로 한다.
2. `부모의 부모`가 루트 노드가 아니었을 시 4번원칙을 위배할 수 있다. `부모의 부모`가 루트 노드일 시  검정색으로 한다.

### HashTable
#### 특징
내부적으로 `배열`을 사용하여 저장한다.
**특별한 알고리즘**을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만든 후 이를 인덱스로 사용한다.

#### Resolve Conflict
1. Open Address
충돌이 발생하며 다른해시 버킷에 해당 자료를 삽입한다.
	1. Linear Probing
		순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.
	2. Quadratic probing
		2차 함수를 이용해 탐색할 위치를 찾는다.
	3. Double hashing probing
		하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬함수를 이용해 
		새 주소를 할당한다. 위 두개 방법에비해 많은 연산량을 요구한다.

2. Separate Chaning
해시충돌이 나지 않도록 보조 해시 함수를 사용하는 것
	- 연결리스트를 사용하는 방법
		각각의 버킷을 연결리스트로 만들어 충돌이 발생하면 해당 bucket의 list에 추가하는 방식이다. 작은 데이터들을 저장할 때 연결리스트 자체의 오버헤드가 부담이 된다.
	- Tree를 사용하는 방법

데이터의 개수가 적을 때는 연결리스트, 데이터의 개수가 많을 때는 트리를 사용한다.
키-값 쌍의 개수가 6개, 8개를 기준으로 결정한다.

### Graph

#### 용어
정점
간선
Degree: 각 정점에서 연결된 Edge의 개수

#### 구현방법
인접행렬: 정방행렬을 사용, Dense graph를 사용할 때 적절하다.
인접리스트: 연결리스트를 사용 Sparse graph를 사용할 때 적절하다.

#### 그래프 탐색
깊이우선탐색
임의의 한 정점으로부터 연결되어 있는 한 정점으로 나아간다라는 방법을 우선으로 탐색한다. Stack을 사용
너비우선탐색
Tree의 Level Order Traversal 형식으로 진행된다. Queue를 사용

## Network

### HTTP, GET, POST
#### GET
`HTTP Request Message`의 Header 부분에 url에 담겨서 전송된다.
데이터 크기 또한 제한적이다. url이 노출되므로 보안상 적절치 않다.
브라우저가 캐싱 가능하다.

#### POST
`HTTP Request Message`의 Body 부분에 데잍가 담겨 전송된다.
데이터 크기가 제한되지 않고 GET 방식보다 보안면에서 낫다.

### 3-way-handshake

#### Connection Establishment
[링크](http://asfirstalways.tistory.com/356)

### TCP, UDP

#### UDP
비 연결형 프로토콜
흐름제어, 오류제어, 손상된 세그먼트 수신에 대한 재전송을 하지 않는다.

#### TCP
신뢰성, 순차적 전달
전 이중, 점대점

### HTTP, HTTPS

#### HTTP의 문제점
- 평문 통신
- 통신 상대를 몰라 위장이 가능
- 완전성을 증명할 수 없기때문에 변조가 가능

#### 보안방법
- 통신 자체를 암호화(SSL, TLS), 콘텐츠를 암호화(HTTP 메세지의 콘텐츠만)
- 증명기관을 이용

#### HTTPS
SSL을 사용한 HTTP
HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게된다.

### 웹 통신의 흐름
1. 브라우저가 URL을 조사
2. HTTP Request 메세지를 생성
3. 프로토콜 스택(운영체제 내 네트워크 제어용 소프트웨어)가 메세지를 받음
4. 패킷 속에 저장하고 제어 정보를 덧붙임
5. 패킷을 LAN 어댑터로 넘김
6. 전기신호로 변환 후 송출
7. 스위칭 허브를 통하여 인터넷 접속용 라우터에 도착
8. 패킷을 ISP 라우터로 전송
9. 인터넷에 들어감
10. 액세스 회선에 의해 POP(Point of Presence, 통신사용 라우터)까지 운반됨 
11. POP로 거쳐 인터넷의 핵심부로 들어감
12. 라우터를 흘러 목적지로 도착
13. 웹 서버의 LAN으로 도착
14. 도착한 패킷을 검사하여 방화벽 및 캐시서버를 사용하여 Response해줄지 검사
15. 물리적 웹 서버에 도착하면 패킷을 추출하여 메세지를 복원 후 웹 서버 애플리케이션으로 넘김
16. 메세지를 받은 웹 서버 애플리케이션은 요청 메세지에 따른 데이터 응답 메세지를 넣어 클라이언트로 회송
17. 왔던 방식으로 메세지가 클라이언트에게 전달됨
